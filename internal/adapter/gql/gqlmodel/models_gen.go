// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlmodel

import (
	"fmt"
	"io"
	"net/url"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/reearth/reearth-backend/internal/usecase"
	"golang.org/x/text/language"
)

type Layer interface {
	IsLayer()
}

type LayerTag interface {
	IsLayerTag()
}

type Node interface {
	IsNode()
}

type PropertyItem interface {
	IsPropertyItem()
}

type Tag interface {
	IsTag()
}

type AddClusterInput struct {
	SceneID ID     `json:"sceneId"`
	Name    string `json:"name"`
}

type AddClusterPayload struct {
	Scene   *Scene   `json:"scene"`
	Cluster *Cluster `json:"cluster"`
}

type AddDatasetSchemaInput struct {
	SceneID             ID     `json:"sceneId"`
	Name                string `json:"name"`
	Representativefield *ID    `json:"representativefield"`
}

type AddDatasetSchemaPayload struct {
	DatasetSchema *DatasetSchema `json:"datasetSchema"`
}

type AddDynamicDatasetInput struct {
	DatasetSchemaID ID       `json:"datasetSchemaId"`
	Author          string   `json:"author"`
	Content         string   `json:"content"`
	Lat             *float64 `json:"lat"`
	Lng             *float64 `json:"lng"`
	Target          *string  `json:"target"`
}

type AddDynamicDatasetPayload struct {
	DatasetSchema *DatasetSchema `json:"datasetSchema"`
	Dataset       *Dataset       `json:"dataset"`
}

type AddDynamicDatasetSchemaInput struct {
	SceneID ID `json:"sceneId"`
}

type AddDynamicDatasetSchemaPayload struct {
	DatasetSchema *DatasetSchema `json:"datasetSchema"`
}

type AddInfoboxFieldInput struct {
	LayerID     ID   `json:"layerId"`
	PluginID    ID   `json:"pluginId"`
	ExtensionID ID   `json:"extensionId"`
	Index       *int `json:"index"`
}

type AddInfoboxFieldPayload struct {
	InfoboxField *InfoboxField `json:"infoboxField"`
	Layer        Layer         `json:"layer"`
}

type AddLayerGroupInput struct {
	ParentLayerID         ID      `json:"parentLayerId"`
	PluginID              *ID     `json:"pluginId"`
	ExtensionID           *ID     `json:"extensionId"`
	Index                 *int    `json:"index"`
	LinkedDatasetSchemaID *ID     `json:"linkedDatasetSchemaID"`
	Name                  *string `json:"name"`
	RepresentativeFieldID *ID     `json:"representativeFieldId"`
}

type AddLayerGroupPayload struct {
	Layer       *LayerGroup `json:"layer"`
	ParentLayer *LayerGroup `json:"parentLayer"`
	Index       *int        `json:"index"`
}

type AddLayerItemInput struct {
	ParentLayerID ID       `json:"parentLayerId"`
	PluginID      ID       `json:"pluginId"`
	ExtensionID   ID       `json:"extensionId"`
	Index         *int     `json:"index"`
	Name          *string  `json:"name"`
	Lat           *float64 `json:"lat"`
	Lng           *float64 `json:"lng"`
}

type AddLayerItemPayload struct {
	Layer       *LayerItem  `json:"layer"`
	ParentLayer *LayerGroup `json:"parentLayer"`
	Index       *int        `json:"index"`
}

type AddMemberToTeamInput struct {
	TeamID ID   `json:"teamId"`
	UserID ID   `json:"userId"`
	Role   Role `json:"role"`
}

type AddMemberToTeamPayload struct {
	Team *Team `json:"team"`
}

type AddPropertyItemInput struct {
	PropertyID     ID          `json:"propertyId"`
	SchemaGroupID  ID          `json:"schemaGroupId"`
	Index          *int        `json:"index"`
	NameFieldValue interface{} `json:"nameFieldValue"`
	NameFieldType  *ValueType  `json:"nameFieldType"`
}

type AddWidgetInput struct {
	SceneID     ID `json:"sceneId"`
	PluginID    ID `json:"pluginId"`
	ExtensionID ID `json:"extensionId"`
}

type AddWidgetPayload struct {
	Scene       *Scene       `json:"scene"`
	SceneWidget *SceneWidget `json:"sceneWidget"`
}

type Asset struct {
	ID          ID        `json:"id"`
	CreatedAt   time.Time `json:"createdAt"`
	TeamID      ID        `json:"teamId"`
	Name        string    `json:"name"`
	Size        int64     `json:"size"`
	URL         string    `json:"url"`
	ContentType string    `json:"contentType"`
	Team        *Team     `json:"team"`
}

func (Asset) IsNode() {}

type AssetConnection struct {
	Edges      []*AssetEdge `json:"edges"`
	Nodes      []*Asset     `json:"nodes"`
	PageInfo   *PageInfo    `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

type AssetEdge struct {
	Cursor usecase.Cursor `json:"cursor"`
	Node   *Asset         `json:"node"`
}

type AttachTagItemToGroupInput struct {
	ItemID  ID `json:"itemID"`
	GroupID ID `json:"groupID"`
}

type AttachTagItemToGroupPayload struct {
	Tag *TagGroup `json:"tag"`
}

type AttachTagToLayerInput struct {
	TagID   ID `json:"tagID"`
	LayerID ID `json:"layerID"`
}

type AttachTagToLayerPayload struct {
	Layer Layer `json:"layer"`
}

type Camera struct {
	Lat      float64 `json:"lat"`
	Lng      float64 `json:"lng"`
	Altitude float64 `json:"altitude"`
	Heading  float64 `json:"heading"`
	Pitch    float64 `json:"pitch"`
	Roll     float64 `json:"roll"`
	Fov      float64 `json:"fov"`
}

type Cluster struct {
	ID         ID        `json:"id"`
	Name       string    `json:"name"`
	PropertyID ID        `json:"propertyId"`
	Property   *Property `json:"property"`
}

type CreateAssetInput struct {
	TeamID ID             `json:"teamId"`
	File   graphql.Upload `json:"file"`
}

type CreateAssetPayload struct {
	Asset *Asset `json:"asset"`
}

type CreateInfoboxInput struct {
	LayerID ID `json:"layerId"`
}

type CreateInfoboxPayload struct {
	Layer Layer `json:"layer"`
}

type CreateProjectInput struct {
	TeamID      ID         `json:"teamId"`
	Visualizer  Visualizer `json:"visualizer"`
	Name        *string    `json:"name"`
	Description *string    `json:"description"`
	ImageURL    *url.URL   `json:"imageUrl"`
	Alias       *string    `json:"alias"`
	Archived    *bool      `json:"archived"`
}

type CreateSceneInput struct {
	ProjectID ID `json:"projectId"`
}

type CreateScenePayload struct {
	Scene *Scene `json:"scene"`
}

type CreateTagGroupInput struct {
	SceneID ID     `json:"sceneId"`
	Label   string `json:"label"`
	Tags    []ID   `json:"tags"`
}

type CreateTagGroupPayload struct {
	Tag *TagGroup `json:"tag"`
}

type CreateTagItemInput struct {
	SceneID               ID     `json:"sceneId"`
	Label                 string `json:"label"`
	Parent                *ID    `json:"parent"`
	LinkedDatasetSchemaID *ID    `json:"linkedDatasetSchemaID"`
	LinkedDatasetID       *ID    `json:"linkedDatasetID"`
	LinkedDatasetField    *ID    `json:"linkedDatasetField"`
}

type CreateTagItemPayload struct {
	Tag    *TagItem  `json:"tag"`
	Parent *TagGroup `json:"parent"`
}

type CreateTeamInput struct {
	Name string `json:"name"`
}

type CreateTeamPayload struct {
	Team *Team `json:"team"`
}

type Dataset struct {
	ID       ID              `json:"id"`
	Source   string          `json:"source"`
	SchemaID ID              `json:"schemaId"`
	Fields   []*DatasetField `json:"fields"`
	Schema   *DatasetSchema  `json:"schema"`
	Name     *string         `json:"name"`
}

func (Dataset) IsNode() {}

type DatasetConnection struct {
	Edges      []*DatasetEdge `json:"edges"`
	Nodes      []*Dataset     `json:"nodes"`
	PageInfo   *PageInfo      `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

type DatasetEdge struct {
	Cursor usecase.Cursor `json:"cursor"`
	Node   *Dataset       `json:"node"`
}

type DatasetField struct {
	FieldID  ID                  `json:"fieldId"`
	SchemaID ID                  `json:"schemaId"`
	Source   string              `json:"source"`
	Type     ValueType           `json:"type"`
	Value    interface{}         `json:"value"`
	Schema   *DatasetSchema      `json:"schema"`
	Field    *DatasetSchemaField `json:"field"`
	ValueRef *Dataset            `json:"valueRef"`
}

type DatasetSchema struct {
	ID                    ID                    `json:"id"`
	Source                string                `json:"source"`
	Name                  string                `json:"name"`
	SceneID               ID                    `json:"sceneId"`
	Fields                []*DatasetSchemaField `json:"fields"`
	TotalCount            int                   `json:"totalCount"`
	RepresentativeFieldID *ID                   `json:"representativeFieldId"`
	Dynamic               *bool                 `json:"dynamic"`
	Datasets              *DatasetConnection    `json:"datasets"`
	Scene                 *Scene                `json:"scene"`
	RepresentativeField   *DatasetSchemaField   `json:"representativeField"`
}

func (DatasetSchema) IsNode() {}

type DatasetSchemaConnection struct {
	Edges      []*DatasetSchemaEdge `json:"edges"`
	Nodes      []*DatasetSchema     `json:"nodes"`
	PageInfo   *PageInfo            `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

type DatasetSchemaEdge struct {
	Cursor usecase.Cursor `json:"cursor"`
	Node   *DatasetSchema `json:"node"`
}

type DatasetSchemaField struct {
	ID       ID             `json:"id"`
	Source   string         `json:"source"`
	Name     string         `json:"name"`
	Type     ValueType      `json:"type"`
	SchemaID ID             `json:"schemaId"`
	RefID    *ID            `json:"refId"`
	Schema   *DatasetSchema `json:"schema"`
	Ref      *DatasetSchema `json:"ref"`
}

func (DatasetSchemaField) IsNode() {}

type DeleteMeInput struct {
	UserID ID `json:"userId"`
}

type DeleteMePayload struct {
	UserID ID `json:"userId"`
}

type DeleteProjectInput struct {
	ProjectID ID `json:"projectId"`
}

type DeleteProjectPayload struct {
	ProjectID ID `json:"projectId"`
}

type DeleteTeamInput struct {
	TeamID ID `json:"teamId"`
}

type DeleteTeamPayload struct {
	TeamID ID `json:"teamId"`
}

type DetachTagFromLayerInput struct {
	TagID   ID `json:"tagID"`
	LayerID ID `json:"layerID"`
}

type DetachTagFromLayerPayload struct {
	Layer Layer `json:"layer"`
}

type DetachTagItemFromGroupInput struct {
	ItemID  ID `json:"itemID"`
	GroupID ID `json:"groupID"`
}

type DetachTagItemFromGroupPayload struct {
	Tag *TagGroup `json:"tag"`
}

type ImportDatasetFromGoogleSheetInput struct {
	AccessToken     string `json:"accessToken"`
	FileID          string `json:"fileId"`
	SheetName       string `json:"sheetName"`
	SceneID         ID     `json:"sceneId"`
	DatasetSchemaID *ID    `json:"datasetSchemaId"`
}

type ImportDatasetInput struct {
	File            graphql.Upload `json:"file"`
	SceneID         ID             `json:"sceneId"`
	DatasetSchemaID *ID            `json:"datasetSchemaId"`
}

type ImportDatasetPayload struct {
	DatasetSchema *DatasetSchema `json:"datasetSchema"`
}

type ImportLayerInput struct {
	LayerID ID                  `json:"layerId"`
	File    graphql.Upload      `json:"file"`
	Format  LayerEncodingFormat `json:"format"`
}

type ImportLayerPayload struct {
	Layers      []Layer     `json:"layers"`
	ParentLayer *LayerGroup `json:"parentLayer"`
}

type Infobox struct {
	SceneID         ID              `json:"sceneId"`
	LayerID         ID              `json:"layerId"`
	PropertyID      ID              `json:"propertyId"`
	Fields          []*InfoboxField `json:"fields"`
	LinkedDatasetID *ID             `json:"linkedDatasetId"`
	Layer           Layer           `json:"layer"`
	Property        *Property       `json:"property"`
	LinkedDataset   *Dataset        `json:"linkedDataset"`
	Merged          *MergedInfobox  `json:"merged"`
	Scene           *Scene          `json:"scene"`
}

type InfoboxField struct {
	ID              ID                  `json:"id"`
	SceneID         ID                  `json:"sceneId"`
	LayerID         ID                  `json:"layerId"`
	PropertyID      ID                  `json:"propertyId"`
	PluginID        ID                  `json:"pluginId"`
	ExtensionID     ID                  `json:"extensionId"`
	LinkedDatasetID *ID                 `json:"linkedDatasetId"`
	Layer           Layer               `json:"layer"`
	Infobox         *Infobox            `json:"infobox"`
	Property        *Property           `json:"property"`
	Plugin          *Plugin             `json:"plugin"`
	Extension       *PluginExtension    `json:"extension"`
	LinkedDataset   *Dataset            `json:"linkedDataset"`
	Merged          *MergedInfoboxField `json:"merged"`
	Scene           *Scene              `json:"scene"`
	ScenePlugin     *ScenePlugin        `json:"scenePlugin"`
}

type InstallPluginInput struct {
	SceneID  ID `json:"sceneId"`
	PluginID ID `json:"pluginId"`
}

type InstallPluginPayload struct {
	Scene       *Scene       `json:"scene"`
	ScenePlugin *ScenePlugin `json:"scenePlugin"`
}

type LatLng struct {
	Lat float64 `json:"lat"`
	Lng float64 `json:"lng"`
}

type LatLngHeight struct {
	Lat    float64 `json:"lat"`
	Lng    float64 `json:"lng"`
	Height float64 `json:"height"`
}

type LayerGroup struct {
	ID                    ID               `json:"id"`
	SceneID               ID               `json:"sceneId"`
	Name                  string           `json:"name"`
	IsVisible             bool             `json:"isVisible"`
	PropertyID            *ID              `json:"propertyId"`
	PluginID              *ID              `json:"pluginId"`
	ExtensionID           *ID              `json:"extensionId"`
	Infobox               *Infobox         `json:"infobox"`
	ParentID              *ID              `json:"parentId"`
	LinkedDatasetSchemaID *ID              `json:"linkedDatasetSchemaId"`
	Root                  bool             `json:"root"`
	LayerIds              []ID             `json:"layerIds"`
	Tags                  []LayerTag       `json:"tags"`
	Parent                *LayerGroup      `json:"parent"`
	Property              *Property        `json:"property"`
	Plugin                *Plugin          `json:"plugin"`
	Extension             *PluginExtension `json:"extension"`
	LinkedDatasetSchema   *DatasetSchema   `json:"linkedDatasetSchema"`
	Layers                []Layer          `json:"layers"`
	Scene                 *Scene           `json:"scene"`
	ScenePlugin           *ScenePlugin     `json:"scenePlugin"`
}

func (LayerGroup) IsLayer() {}

type LayerItem struct {
	ID              ID               `json:"id"`
	SceneID         ID               `json:"sceneId"`
	Name            string           `json:"name"`
	IsVisible       bool             `json:"isVisible"`
	PropertyID      *ID              `json:"propertyId"`
	PluginID        *ID              `json:"pluginId"`
	ExtensionID     *ID              `json:"extensionId"`
	Infobox         *Infobox         `json:"infobox"`
	ParentID        *ID              `json:"parentId"`
	LinkedDatasetID *ID              `json:"linkedDatasetId"`
	Tags            []LayerTag       `json:"tags"`
	Parent          *LayerGroup      `json:"parent"`
	Property        *Property        `json:"property"`
	Plugin          *Plugin          `json:"plugin"`
	Extension       *PluginExtension `json:"extension"`
	LinkedDataset   *Dataset         `json:"linkedDataset"`
	Merged          *MergedLayer     `json:"merged"`
	Scene           *Scene           `json:"scene"`
	ScenePlugin     *ScenePlugin     `json:"scenePlugin"`
}

func (LayerItem) IsLayer() {}

type LayerTagGroup struct {
	TagID    ID              `json:"tagId"`
	Children []*LayerTagItem `json:"children"`
	Tag      Tag             `json:"tag"`
}

func (LayerTagGroup) IsLayerTag() {}

type LayerTagItem struct {
	TagID ID  `json:"tagId"`
	Tag   Tag `json:"tag"`
}

func (LayerTagItem) IsLayerTag() {}

type LinkDatasetToPropertyValueInput struct {
	PropertyID            ID   `json:"propertyId"`
	SchemaGroupID         *ID  `json:"schemaGroupId"`
	ItemID                *ID  `json:"itemId"`
	FieldID               ID   `json:"fieldId"`
	DatasetSchemaIds      []ID `json:"datasetSchemaIds"`
	DatasetSchemaFieldIds []ID `json:"datasetSchemaFieldIds"`
	DatasetIds            []ID `json:"datasetIds"`
}

type Me struct {
	ID       ID           `json:"id"`
	Name     string       `json:"name"`
	Email    string       `json:"email"`
	Lang     language.Tag `json:"lang"`
	Theme    Theme        `json:"theme"`
	MyTeamID ID           `json:"myTeamId"`
	Auths    []string     `json:"auths"`
	Teams    []*Team      `json:"teams"`
	MyTeam   *Team        `json:"myTeam"`
}

type MergedInfobox struct {
	SceneID  ID                    `json:"sceneID"`
	Property *MergedProperty       `json:"property"`
	Fields   []*MergedInfoboxField `json:"fields"`
	Scene    *Scene                `json:"scene"`
}

type MergedInfoboxField struct {
	OriginalID  ID               `json:"originalId"`
	SceneID     ID               `json:"sceneID"`
	PluginID    ID               `json:"pluginId"`
	ExtensionID ID               `json:"extensionId"`
	Property    *MergedProperty  `json:"property"`
	Plugin      *Plugin          `json:"plugin"`
	Extension   *PluginExtension `json:"extension"`
	Scene       *Scene           `json:"scene"`
	ScenePlugin *ScenePlugin     `json:"scenePlugin"`
}

type MergedLayer struct {
	OriginalID ID              `json:"originalId"`
	ParentID   *ID             `json:"parentId"`
	SceneID    ID              `json:"sceneID"`
	Property   *MergedProperty `json:"property"`
	Infobox    *MergedInfobox  `json:"infobox"`
	Original   *LayerItem      `json:"original"`
	Parent     *LayerGroup     `json:"parent"`
	Scene      *Scene          `json:"scene"`
}

type MergedProperty struct {
	OriginalID      *ID                    `json:"originalId"`
	ParentID        *ID                    `json:"parentId"`
	SchemaID        *ID                    `json:"schemaId"`
	LinkedDatasetID *ID                    `json:"linkedDatasetId"`
	Original        *Property              `json:"original"`
	Parent          *Property              `json:"parent"`
	Schema          *PropertySchema        `json:"schema"`
	LinkedDataset   *Dataset               `json:"linkedDataset"`
	Groups          []*MergedPropertyGroup `json:"groups"`
}

type MergedPropertyField struct {
	SchemaID    ID                   `json:"schemaId"`
	FieldID     ID                   `json:"fieldId"`
	Value       interface{}          `json:"value"`
	Type        ValueType            `json:"type"`
	Links       []*PropertyFieldLink `json:"links"`
	Overridden  bool                 `json:"overridden"`
	Schema      *PropertySchema      `json:"schema"`
	Field       *PropertySchemaField `json:"field"`
	ActualValue interface{}          `json:"actualValue"`
}

type MergedPropertyGroup struct {
	OriginalPropertyID *ID                    `json:"originalPropertyId"`
	ParentPropertyID   *ID                    `json:"parentPropertyId"`
	OriginalID         *ID                    `json:"originalId"`
	ParentID           *ID                    `json:"parentId"`
	SchemaGroupID      ID                     `json:"schemaGroupId"`
	SchemaID           *ID                    `json:"schemaId"`
	LinkedDatasetID    *ID                    `json:"linkedDatasetId"`
	Fields             []*MergedPropertyField `json:"fields"`
	Groups             []*MergedPropertyGroup `json:"groups"`
	OriginalProperty   *Property              `json:"originalProperty"`
	ParentProperty     *Property              `json:"parentProperty"`
	Original           *PropertyGroup         `json:"original"`
	Parent             *PropertyGroup         `json:"parent"`
	Schema             *PropertySchema        `json:"schema"`
	LinkedDataset      *Dataset               `json:"linkedDataset"`
}

type MoveInfoboxFieldInput struct {
	LayerID        ID  `json:"layerId"`
	InfoboxFieldID ID  `json:"infoboxFieldId"`
	Index          int `json:"index"`
}

type MoveInfoboxFieldPayload struct {
	InfoboxFieldID ID    `json:"infoboxFieldId"`
	Layer          Layer `json:"layer"`
	Index          int   `json:"index"`
}

type MoveLayerInput struct {
	LayerID     ID   `json:"layerId"`
	DestLayerID *ID  `json:"destLayerId"`
	Index       *int `json:"index"`
}

type MoveLayerPayload struct {
	LayerID         ID          `json:"layerId"`
	FromParentLayer *LayerGroup `json:"fromParentLayer"`
	ToParentLayer   *LayerGroup `json:"toParentLayer"`
	Index           int         `json:"index"`
}

type MovePropertyItemInput struct {
	PropertyID    ID  `json:"propertyId"`
	SchemaGroupID ID  `json:"schemaGroupId"`
	ItemID        ID  `json:"itemId"`
	Index         int `json:"index"`
}

type PageInfo struct {
	StartCursor     *usecase.Cursor `json:"startCursor"`
	EndCursor       *usecase.Cursor `json:"endCursor"`
	HasNextPage     bool            `json:"hasNextPage"`
	HasPreviousPage bool            `json:"hasPreviousPage"`
}

type Pagination struct {
	First  *int            `json:"first"`
	Last   *int            `json:"last"`
	After  *usecase.Cursor `json:"after"`
	Before *usecase.Cursor `json:"before"`
}

type Plugin struct {
	ID                       ID                 `json:"id"`
	SceneID                  *ID                `json:"sceneId"`
	Name                     string             `json:"name"`
	Version                  string             `json:"version"`
	Description              string             `json:"description"`
	Author                   string             `json:"author"`
	RepositoryURL            string             `json:"repositoryUrl"`
	PropertySchemaID         *ID                `json:"propertySchemaId"`
	Extensions               []*PluginExtension `json:"extensions"`
	ScenePlugin              *ScenePlugin       `json:"scenePlugin"`
	AllTranslatedDescription map[string]string  `json:"allTranslatedDescription"`
	AllTranslatedName        map[string]string  `json:"allTranslatedName"`
	Scene                    *Scene             `json:"scene"`
	TranslatedName           string             `json:"translatedName"`
	TranslatedDescription    string             `json:"translatedDescription"`
	PropertySchema           *PropertySchema    `json:"propertySchema"`
}

type PluginExtension struct {
	ExtensionID              ID                  `json:"extensionId"`
	PluginID                 ID                  `json:"pluginId"`
	Type                     PluginExtensionType `json:"type"`
	Name                     string              `json:"name"`
	Description              string              `json:"description"`
	Icon                     string              `json:"icon"`
	SingleOnly               *bool               `json:"singleOnly"`
	WidgetLayout             *WidgetLayout       `json:"widgetLayout"`
	Visualizer               *Visualizer         `json:"visualizer"`
	PropertySchemaID         ID                  `json:"propertySchemaId"`
	AllTranslatedName        map[string]string   `json:"allTranslatedName"`
	AllTranslatedDescription map[string]string   `json:"allTranslatedDescription"`
	Plugin                   *Plugin             `json:"plugin"`
	SceneWidget              *SceneWidget        `json:"sceneWidget"`
	PropertySchema           *PropertySchema     `json:"propertySchema"`
	TranslatedName           string              `json:"translatedName"`
	TranslatedDescription    string              `json:"translatedDescription"`
}

type Project struct {
	ID                ID                `json:"id"`
	IsArchived        bool              `json:"isArchived"`
	IsBasicAuthActive bool              `json:"isBasicAuthActive"`
	BasicAuthUsername string            `json:"basicAuthUsername"`
	BasicAuthPassword string            `json:"basicAuthPassword"`
	CreatedAt         time.Time         `json:"createdAt"`
	UpdatedAt         time.Time         `json:"updatedAt"`
	PublishedAt       *time.Time        `json:"publishedAt"`
	Name              string            `json:"name"`
	Description       string            `json:"description"`
	Alias             string            `json:"alias"`
	PublicTitle       string            `json:"publicTitle"`
	PublicDescription string            `json:"publicDescription"`
	PublicImage       string            `json:"publicImage"`
	PublicNoIndex     bool              `json:"publicNoIndex"`
	ImageURL          *url.URL          `json:"imageUrl"`
	TeamID            ID                `json:"teamId"`
	Visualizer        Visualizer        `json:"visualizer"`
	PublishmentStatus PublishmentStatus `json:"publishmentStatus"`
	Team              *Team             `json:"team"`
	Scene             *Scene            `json:"scene"`
}

func (Project) IsNode() {}

type ProjectAliasAvailability struct {
	Alias     string `json:"alias"`
	Available bool   `json:"available"`
}

type ProjectConnection struct {
	Edges      []*ProjectEdge `json:"edges"`
	Nodes      []*Project     `json:"nodes"`
	PageInfo   *PageInfo      `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

type ProjectEdge struct {
	Cursor usecase.Cursor `json:"cursor"`
	Node   *Project       `json:"node"`
}

type ProjectPayload struct {
	Project *Project `json:"project"`
}

type Property struct {
	ID       ID              `json:"id"`
	SchemaID ID              `json:"schemaId"`
	Items    []PropertyItem  `json:"items"`
	Schema   *PropertySchema `json:"schema"`
	Layer    Layer           `json:"layer"`
	Merged   *MergedProperty `json:"merged"`
}

func (Property) IsNode() {}

type PropertyCondition struct {
	FieldID ID          `json:"fieldId"`
	Type    ValueType   `json:"type"`
	Value   interface{} `json:"value"`
}

type PropertyField struct {
	ID          string               `json:"id"`
	ParentID    ID                   `json:"parentId"`
	SchemaID    ID                   `json:"schemaId"`
	FieldID     ID                   `json:"fieldId"`
	Links       []*PropertyFieldLink `json:"links"`
	Type        ValueType            `json:"type"`
	Value       interface{}          `json:"value"`
	Parent      *Property            `json:"parent"`
	Schema      *PropertySchema      `json:"schema"`
	Field       *PropertySchemaField `json:"field"`
	ActualValue interface{}          `json:"actualValue"`
}

type PropertyFieldLink struct {
	DatasetID            *ID                 `json:"datasetId"`
	DatasetSchemaID      ID                  `json:"datasetSchemaId"`
	DatasetSchemaFieldID ID                  `json:"datasetSchemaFieldId"`
	Dataset              *Dataset            `json:"dataset"`
	DatasetField         *DatasetField       `json:"datasetField"`
	DatasetSchema        *DatasetSchema      `json:"datasetSchema"`
	DatasetSchemaField   *DatasetSchemaField `json:"datasetSchemaField"`
}

type PropertyFieldPayload struct {
	Property      *Property      `json:"property"`
	PropertyField *PropertyField `json:"propertyField"`
}

type PropertyGroup struct {
	ID            ID                   `json:"id"`
	SchemaID      ID                   `json:"schemaId"`
	SchemaGroupID ID                   `json:"schemaGroupId"`
	Fields        []*PropertyField     `json:"fields"`
	Schema        *PropertySchema      `json:"schema"`
	SchemaGroup   *PropertySchemaGroup `json:"schemaGroup"`
}

func (PropertyGroup) IsPropertyItem() {}

type PropertyGroupList struct {
	ID            ID                   `json:"id"`
	SchemaID      ID                   `json:"schemaId"`
	SchemaGroupID ID                   `json:"schemaGroupId"`
	Groups        []*PropertyGroup     `json:"groups"`
	Schema        *PropertySchema      `json:"schema"`
	SchemaGroup   *PropertySchemaGroup `json:"schemaGroup"`
}

func (PropertyGroupList) IsPropertyItem() {}

type PropertyItemPayload struct {
	Property     *Property    `json:"property"`
	PropertyItem PropertyItem `json:"propertyItem"`
}

type PropertyLinkableFields struct {
	SchemaID    ID                   `json:"schemaId"`
	Latlng      *ID                  `json:"latlng"`
	URL         *ID                  `json:"url"`
	LatlngField *PropertySchemaField `json:"latlngField"`
	URLField    *PropertySchemaField `json:"urlField"`
	Schema      *PropertySchema      `json:"schema"`
}

type PropertySchema struct {
	ID             ID                      `json:"id"`
	Groups         []*PropertySchemaGroup  `json:"groups"`
	LinkableFields *PropertyLinkableFields `json:"linkableFields"`
}

type PropertySchemaField struct {
	FieldID                  ID                           `json:"fieldId"`
	Type                     ValueType                    `json:"type"`
	Title                    string                       `json:"title"`
	Description              string                       `json:"description"`
	Prefix                   *string                      `json:"prefix"`
	Suffix                   *string                      `json:"suffix"`
	DefaultValue             interface{}                  `json:"defaultValue"`
	UI                       *PropertySchemaFieldUI       `json:"ui"`
	Min                      *float64                     `json:"min"`
	Max                      *float64                     `json:"max"`
	Choices                  []*PropertySchemaFieldChoice `json:"choices"`
	IsAvailableIf            *PropertyCondition           `json:"isAvailableIf"`
	AllTranslatedTitle       map[string]string            `json:"allTranslatedTitle"`
	AllTranslatedDescription map[string]string            `json:"allTranslatedDescription"`
	TranslatedTitle          string                       `json:"translatedTitle"`
	TranslatedDescription    string                       `json:"translatedDescription"`
}

type PropertySchemaFieldChoice struct {
	Key                string            `json:"key"`
	Title              string            `json:"title"`
	Icon               *string           `json:"icon"`
	AllTranslatedTitle map[string]string `json:"allTranslatedTitle"`
	TranslatedTitle    string            `json:"translatedTitle"`
}

type PropertySchemaGroup struct {
	SchemaGroupID         ID                     `json:"schemaGroupId"`
	SchemaID              ID                     `json:"schemaId"`
	Fields                []*PropertySchemaField `json:"fields"`
	IsList                bool                   `json:"isList"`
	IsAvailableIf         *PropertyCondition     `json:"isAvailableIf"`
	Title                 *string                `json:"title"`
	AllTranslatedTitle    map[string]string      `json:"allTranslatedTitle"`
	RepresentativeFieldID *ID                    `json:"representativeFieldId"`
	RepresentativeField   *PropertySchemaField   `json:"representativeField"`
	Schema                *PropertySchema        `json:"schema"`
	TranslatedTitle       string                 `json:"translatedTitle"`
}

type PublishProjectInput struct {
	ProjectID ID                `json:"projectId"`
	Alias     *string           `json:"alias"`
	Status    PublishmentStatus `json:"status"`
}

type Rect struct {
	West  float64 `json:"west"`
	South float64 `json:"south"`
	East  float64 `json:"east"`
	North float64 `json:"north"`
}

type RemoveAssetInput struct {
	AssetID ID `json:"assetId"`
}

type RemoveAssetPayload struct {
	AssetID ID `json:"assetId"`
}

type RemoveClusterInput struct {
	ClusterID ID `json:"clusterId"`
	SceneID   ID `json:"sceneId"`
}

type RemoveClusterPayload struct {
	Scene     *Scene `json:"scene"`
	ClusterID ID     `json:"clusterId"`
}

type RemoveDatasetSchemaInput struct {
	SchemaID ID    `json:"schemaId"`
	Force    *bool `json:"force"`
}

type RemoveDatasetSchemaPayload struct {
	SchemaID ID `json:"schemaId"`
}

type RemoveInfoboxFieldInput struct {
	LayerID        ID `json:"layerId"`
	InfoboxFieldID ID `json:"infoboxFieldId"`
}

type RemoveInfoboxFieldPayload struct {
	InfoboxFieldID ID    `json:"infoboxFieldId"`
	Layer          Layer `json:"layer"`
}

type RemoveInfoboxInput struct {
	LayerID ID `json:"layerId"`
}

type RemoveInfoboxPayload struct {
	Layer Layer `json:"layer"`
}

type RemoveLayerInput struct {
	LayerID ID `json:"layerId"`
}

type RemoveLayerPayload struct {
	LayerID     ID          `json:"layerId"`
	ParentLayer *LayerGroup `json:"parentLayer"`
}

type RemoveMemberFromTeamInput struct {
	TeamID ID `json:"teamId"`
	UserID ID `json:"userId"`
}

type RemoveMemberFromTeamPayload struct {
	Team *Team `json:"team"`
}

type RemoveMyAuthInput struct {
	Auth string `json:"auth"`
}

type RemovePropertyFieldInput struct {
	PropertyID    ID  `json:"propertyId"`
	SchemaGroupID *ID `json:"schemaGroupId"`
	ItemID        *ID `json:"itemId"`
	FieldID       ID  `json:"fieldId"`
}

type RemovePropertyItemInput struct {
	PropertyID    ID `json:"propertyId"`
	SchemaGroupID ID `json:"schemaGroupId"`
	ItemID        ID `json:"itemId"`
}

type RemoveTagInput struct {
	TagID ID `json:"tagID"`
}

type RemoveTagPayload struct {
	TagID         ID      `json:"tagId"`
	UpdatedLayers []Layer `json:"updatedLayers"`
}

type RemoveWidgetInput struct {
	SceneID  ID `json:"sceneId"`
	WidgetID ID `json:"widgetId"`
}

type RemoveWidgetPayload struct {
	Scene    *Scene `json:"scene"`
	WidgetID ID     `json:"widgetId"`
}

type Scene struct {
	ID                    ID                       `json:"id"`
	ProjectID             ID                       `json:"projectId"`
	TeamID                ID                       `json:"teamId"`
	PropertyID            ID                       `json:"propertyId"`
	CreatedAt             time.Time                `json:"createdAt"`
	UpdatedAt             time.Time                `json:"updatedAt"`
	RootLayerID           ID                       `json:"rootLayerId"`
	Widgets               []*SceneWidget           `json:"widgets"`
	Plugins               []*ScenePlugin           `json:"plugins"`
	WidgetAlignSystem     *WidgetAlignSystem       `json:"widgetAlignSystem"`
	DynamicDatasetSchemas []*DatasetSchema         `json:"dynamicDatasetSchemas"`
	Project               *Project                 `json:"project"`
	Team                  *Team                    `json:"team"`
	Property              *Property                `json:"property"`
	RootLayer             *LayerGroup              `json:"rootLayer"`
	DatasetSchemas        *DatasetSchemaConnection `json:"datasetSchemas"`
	TagIds                []ID                     `json:"tagIds"`
	Tags                  []Tag                    `json:"tags"`
	Clusters              []*Cluster               `json:"clusters"`
}

func (Scene) IsNode() {}

type ScenePlugin struct {
	PluginID   ID        `json:"pluginId"`
	PropertyID *ID       `json:"propertyId"`
	Plugin     *Plugin   `json:"plugin"`
	Property   *Property `json:"property"`
}

type SceneWidget struct {
	ID          ID               `json:"id"`
	PluginID    ID               `json:"pluginId"`
	ExtensionID ID               `json:"extensionId"`
	PropertyID  ID               `json:"propertyId"`
	Enabled     bool             `json:"enabled"`
	Extended    bool             `json:"extended"`
	Plugin      *Plugin          `json:"plugin"`
	Extension   *PluginExtension `json:"extension"`
	Property    *Property        `json:"property"`
}

type SignupInput struct {
	Lang   *language.Tag `json:"lang"`
	Theme  *Theme        `json:"theme"`
	UserID *ID           `json:"userId"`
	TeamID *ID           `json:"teamId"`
	Secret *string       `json:"secret"`
}

type SignupPayload struct {
	User *User `json:"user"`
	Team *Team `json:"team"`
}

type SyncDatasetInput struct {
	SceneID ID     `json:"sceneId"`
	URL     string `json:"url"`
}

type SyncDatasetPayload struct {
	SceneID       ID               `json:"sceneId"`
	URL           string           `json:"url"`
	DatasetSchema []*DatasetSchema `json:"datasetSchema"`
	Dataset       []*Dataset       `json:"dataset"`
}

type TagGroup struct {
	ID      ID         `json:"id"`
	SceneID ID         `json:"sceneId"`
	Label   string     `json:"label"`
	TagIds  []ID       `json:"tagIds"`
	Tags    []*TagItem `json:"tags"`
	Scene   *Scene     `json:"scene"`
	Layers  []Layer    `json:"layers"`
}

func (TagGroup) IsTag() {}

type TagItem struct {
	ID                    ID             `json:"id"`
	SceneID               ID             `json:"sceneId"`
	Label                 string         `json:"label"`
	ParentID              *ID            `json:"parentId"`
	LinkedDatasetID       *ID            `json:"linkedDatasetID"`
	LinkedDatasetSchemaID *ID            `json:"linkedDatasetSchemaID"`
	LinkedDatasetFieldID  *ID            `json:"linkedDatasetFieldID"`
	LinkedDatasetSchema   *DatasetSchema `json:"linkedDatasetSchema"`
	LinkedDataset         *Dataset       `json:"linkedDataset"`
	LinkedDatasetField    *DatasetField  `json:"linkedDatasetField"`
	Parent                *TagGroup      `json:"parent"`
	Layers                []Layer        `json:"layers"`
}

func (TagItem) IsTag() {}

type Team struct {
	ID       ID                 `json:"id"`
	Name     string             `json:"name"`
	Members  []*TeamMember      `json:"members"`
	Personal bool               `json:"personal"`
	Assets   *AssetConnection   `json:"assets"`
	Projects *ProjectConnection `json:"projects"`
}

func (Team) IsNode() {}

type TeamMember struct {
	UserID ID    `json:"userId"`
	Role   Role  `json:"role"`
	User   *User `json:"user"`
}

type Typography struct {
	FontFamily *string    `json:"fontFamily"`
	FontWeight *string    `json:"fontWeight"`
	FontSize   *int       `json:"fontSize"`
	Color      *string    `json:"color"`
	TextAlign  *TextAlign `json:"textAlign"`
	Bold       *bool      `json:"bold"`
	Italic     *bool      `json:"italic"`
	Underline  *bool      `json:"underline"`
}

type UninstallPluginInput struct {
	SceneID  ID `json:"sceneId"`
	PluginID ID `json:"pluginId"`
}

type UninstallPluginPayload struct {
	PluginID ID     `json:"pluginId"`
	Scene    *Scene `json:"scene"`
}

type UnlinkPropertyValueInput struct {
	PropertyID    ID  `json:"propertyId"`
	SchemaGroupID *ID `json:"schemaGroupId"`
	ItemID        *ID `json:"itemId"`
	FieldID       ID  `json:"fieldId"`
}

type UpdateClusterInput struct {
	ClusterID  ID      `json:"clusterId"`
	SceneID    ID      `json:"sceneId"`
	Name       *string `json:"name"`
	PropertyID *ID     `json:"propertyId"`
}

type UpdateClusterPayload struct {
	Scene   *Scene   `json:"scene"`
	Cluster *Cluster `json:"cluster"`
}

type UpdateDatasetSchemaInput struct {
	SchemaID ID     `json:"schemaId"`
	Name     string `json:"name"`
}

type UpdateDatasetSchemaPayload struct {
	DatasetSchema *DatasetSchema `json:"datasetSchema"`
}

type UpdateLayerInput struct {
	LayerID ID      `json:"layerId"`
	Name    *string `json:"name"`
	Visible *bool   `json:"visible"`
}

type UpdateLayerPayload struct {
	Layer Layer `json:"layer"`
}

type UpdateMeInput struct {
	Name                 *string       `json:"name"`
	Email                *string       `json:"email"`
	Lang                 *language.Tag `json:"lang"`
	Theme                *Theme        `json:"theme"`
	Password             *string       `json:"password"`
	PasswordConfirmation *string       `json:"passwordConfirmation"`
}

type UpdateMePayload struct {
	Me *Me `json:"me"`
}

type UpdateMemberOfTeamInput struct {
	TeamID ID   `json:"teamId"`
	UserID ID   `json:"userId"`
	Role   Role `json:"role"`
}

type UpdateMemberOfTeamPayload struct {
	Team *Team `json:"team"`
}

type UpdateProjectInput struct {
	ProjectID         ID       `json:"projectId"`
	Name              *string  `json:"name"`
	Description       *string  `json:"description"`
	Archived          *bool    `json:"archived"`
	IsBasicAuthActive *bool    `json:"isBasicAuthActive"`
	BasicAuthUsername *string  `json:"basicAuthUsername"`
	BasicAuthPassword *string  `json:"basicAuthPassword"`
	Alias             *string  `json:"alias"`
	ImageURL          *url.URL `json:"imageUrl"`
	PublicTitle       *string  `json:"publicTitle"`
	PublicDescription *string  `json:"publicDescription"`
	PublicImage       *string  `json:"publicImage"`
	PublicNoIndex     *bool    `json:"publicNoIndex"`
	DeleteImageURL    *bool    `json:"deleteImageUrl"`
	DeletePublicImage *bool    `json:"deletePublicImage"`
}

type UpdatePropertyItemInput struct {
	PropertyID    ID                                  `json:"propertyId"`
	SchemaGroupID ID                                  `json:"schemaGroupId"`
	Operations    []*UpdatePropertyItemOperationInput `json:"operations"`
}

type UpdatePropertyItemOperationInput struct {
	Operation      ListOperation `json:"operation"`
	ItemID         *ID           `json:"itemId"`
	Index          *int          `json:"index"`
	NameFieldValue interface{}   `json:"nameFieldValue"`
	NameFieldType  *ValueType    `json:"nameFieldType"`
}

type UpdatePropertyValueInput struct {
	PropertyID    ID          `json:"propertyId"`
	SchemaGroupID *ID         `json:"schemaGroupId"`
	ItemID        *ID         `json:"itemId"`
	FieldID       ID          `json:"fieldId"`
	Value         interface{} `json:"value"`
	Type          ValueType   `json:"type"`
}

type UpdateTagInput struct {
	TagID   ID      `json:"tagId"`
	SceneID ID      `json:"sceneId"`
	Label   *string `json:"label"`
}

type UpdateTagPayload struct {
	Tag Tag `json:"tag"`
}

type UpdateTeamInput struct {
	TeamID ID     `json:"teamId"`
	Name   string `json:"name"`
}

type UpdateTeamPayload struct {
	Team *Team `json:"team"`
}

type UpdateWidgetAlignSystemInput struct {
	SceneID  ID                   `json:"sceneId"`
	Location *WidgetLocationInput `json:"location"`
	Align    *WidgetAreaAlign     `json:"align"`
}

type UpdateWidgetAlignSystemPayload struct {
	Scene *Scene `json:"scene"`
}

type UpdateWidgetInput struct {
	SceneID  ID                   `json:"sceneId"`
	WidgetID ID                   `json:"widgetId"`
	Enabled  *bool                `json:"enabled"`
	Location *WidgetLocationInput `json:"location"`
	Extended *bool                `json:"extended"`
	Index    *int                 `json:"index"`
}

type UpdateWidgetPayload struct {
	Scene       *Scene       `json:"scene"`
	SceneWidget *SceneWidget `json:"sceneWidget"`
}

type UpgradePluginInput struct {
	SceneID    ID `json:"sceneId"`
	PluginID   ID `json:"pluginId"`
	ToPluginID ID `json:"toPluginId"`
}

type UpgradePluginPayload struct {
	Scene       *Scene       `json:"scene"`
	ScenePlugin *ScenePlugin `json:"scenePlugin"`
}

type UploadFileToPropertyInput struct {
	PropertyID    ID             `json:"propertyId"`
	SchemaGroupID *ID            `json:"schemaGroupId"`
	ItemID        *ID            `json:"itemId"`
	FieldID       ID             `json:"fieldId"`
	File          graphql.Upload `json:"file"`
}

type UploadPluginInput struct {
	SceneID ID              `json:"sceneId"`
	File    *graphql.Upload `json:"file"`
	URL     *url.URL        `json:"url"`
}

type UploadPluginPayload struct {
	Plugin      *Plugin      `json:"plugin"`
	Scene       *Scene       `json:"scene"`
	ScenePlugin *ScenePlugin `json:"scenePlugin"`
}

type User struct {
	ID    ID     `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
}

func (User) IsNode() {}

type WidgetAlignSystem struct {
	Inner *WidgetZone `json:"inner"`
	Outer *WidgetZone `json:"outer"`
}

type WidgetArea struct {
	WidgetIds []ID            `json:"widgetIds"`
	Align     WidgetAreaAlign `json:"align"`
}

type WidgetExtendable struct {
	Vertically   bool `json:"vertically"`
	Horizontally bool `json:"horizontally"`
}

type WidgetLayout struct {
	Extendable      *WidgetExtendable `json:"extendable"`
	Extended        bool              `json:"extended"`
	Floating        bool              `json:"floating"`
	DefaultLocation *WidgetLocation   `json:"defaultLocation"`
}

type WidgetLocation struct {
	Zone    WidgetZoneType    `json:"zone"`
	Section WidgetSectionType `json:"section"`
	Area    WidgetAreaType    `json:"area"`
}

type WidgetLocationInput struct {
	Zone    WidgetZoneType    `json:"zone"`
	Section WidgetSectionType `json:"section"`
	Area    WidgetAreaType    `json:"area"`
}

type WidgetSection struct {
	Top    *WidgetArea `json:"top"`
	Middle *WidgetArea `json:"middle"`
	Bottom *WidgetArea `json:"bottom"`
}

type WidgetZone struct {
	Left   *WidgetSection `json:"left"`
	Center *WidgetSection `json:"center"`
	Right  *WidgetSection `json:"right"`
}

type AssetSortType string

const (
	AssetSortTypeDate AssetSortType = "DATE"
	AssetSortTypeSize AssetSortType = "SIZE"
	AssetSortTypeName AssetSortType = "NAME"
)

var AllAssetSortType = []AssetSortType{
	AssetSortTypeDate,
	AssetSortTypeSize,
	AssetSortTypeName,
}

func (e AssetSortType) IsValid() bool {
	switch e {
	case AssetSortTypeDate, AssetSortTypeSize, AssetSortTypeName:
		return true
	}
	return false
}

func (e AssetSortType) String() string {
	return string(e)
}

func (e *AssetSortType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AssetSortType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AssetSortType", str)
	}
	return nil
}

func (e AssetSortType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LayerEncodingFormat string

const (
	LayerEncodingFormatKml     LayerEncodingFormat = "KML"
	LayerEncodingFormatCzml    LayerEncodingFormat = "CZML"
	LayerEncodingFormatGeojson LayerEncodingFormat = "GEOJSON"
	LayerEncodingFormatShape   LayerEncodingFormat = "SHAPE"
	LayerEncodingFormatReearth LayerEncodingFormat = "REEARTH"
)

var AllLayerEncodingFormat = []LayerEncodingFormat{
	LayerEncodingFormatKml,
	LayerEncodingFormatCzml,
	LayerEncodingFormatGeojson,
	LayerEncodingFormatShape,
	LayerEncodingFormatReearth,
}

func (e LayerEncodingFormat) IsValid() bool {
	switch e {
	case LayerEncodingFormatKml, LayerEncodingFormatCzml, LayerEncodingFormatGeojson, LayerEncodingFormatShape, LayerEncodingFormatReearth:
		return true
	}
	return false
}

func (e LayerEncodingFormat) String() string {
	return string(e)
}

func (e *LayerEncodingFormat) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LayerEncodingFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LayerEncodingFormat", str)
	}
	return nil
}

func (e LayerEncodingFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ListOperation string

const (
	ListOperationAdd    ListOperation = "ADD"
	ListOperationMove   ListOperation = "MOVE"
	ListOperationRemove ListOperation = "REMOVE"
)

var AllListOperation = []ListOperation{
	ListOperationAdd,
	ListOperationMove,
	ListOperationRemove,
}

func (e ListOperation) IsValid() bool {
	switch e {
	case ListOperationAdd, ListOperationMove, ListOperationRemove:
		return true
	}
	return false
}

func (e ListOperation) String() string {
	return string(e)
}

func (e *ListOperation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ListOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ListOperation", str)
	}
	return nil
}

func (e ListOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeType string

const (
	NodeTypeAsset          NodeType = "ASSET"
	NodeTypeUser           NodeType = "USER"
	NodeTypeTeam           NodeType = "TEAM"
	NodeTypeProject        NodeType = "PROJECT"
	NodeTypePlugin         NodeType = "PLUGIN"
	NodeTypeScene          NodeType = "SCENE"
	NodeTypePropertySchema NodeType = "PROPERTY_SCHEMA"
	NodeTypeProperty       NodeType = "PROPERTY"
	NodeTypeDatasetSchema  NodeType = "DATASET_SCHEMA"
	NodeTypeDataset        NodeType = "DATASET"
	NodeTypeLayerGroup     NodeType = "LAYER_GROUP"
	NodeTypeLayerItem      NodeType = "LAYER_ITEM"
)

var AllNodeType = []NodeType{
	NodeTypeAsset,
	NodeTypeUser,
	NodeTypeTeam,
	NodeTypeProject,
	NodeTypePlugin,
	NodeTypeScene,
	NodeTypePropertySchema,
	NodeTypeProperty,
	NodeTypeDatasetSchema,
	NodeTypeDataset,
	NodeTypeLayerGroup,
	NodeTypeLayerItem,
}

func (e NodeType) IsValid() bool {
	switch e {
	case NodeTypeAsset, NodeTypeUser, NodeTypeTeam, NodeTypeProject, NodeTypePlugin, NodeTypeScene, NodeTypePropertySchema, NodeTypeProperty, NodeTypeDatasetSchema, NodeTypeDataset, NodeTypeLayerGroup, NodeTypeLayerItem:
		return true
	}
	return false
}

func (e NodeType) String() string {
	return string(e)
}

func (e *NodeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeType", str)
	}
	return nil
}

func (e NodeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PluginExtensionType string

const (
	PluginExtensionTypePrimitive  PluginExtensionType = "PRIMITIVE"
	PluginExtensionTypeWidget     PluginExtensionType = "WIDGET"
	PluginExtensionTypeBlock      PluginExtensionType = "BLOCK"
	PluginExtensionTypeVisualizer PluginExtensionType = "VISUALIZER"
	PluginExtensionTypeInfobox    PluginExtensionType = "INFOBOX"
)

var AllPluginExtensionType = []PluginExtensionType{
	PluginExtensionTypePrimitive,
	PluginExtensionTypeWidget,
	PluginExtensionTypeBlock,
	PluginExtensionTypeVisualizer,
	PluginExtensionTypeInfobox,
}

func (e PluginExtensionType) IsValid() bool {
	switch e {
	case PluginExtensionTypePrimitive, PluginExtensionTypeWidget, PluginExtensionTypeBlock, PluginExtensionTypeVisualizer, PluginExtensionTypeInfobox:
		return true
	}
	return false
}

func (e PluginExtensionType) String() string {
	return string(e)
}

func (e *PluginExtensionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PluginExtensionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PluginExtensionType", str)
	}
	return nil
}

func (e PluginExtensionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PropertySchemaFieldUI string

const (
	PropertySchemaFieldUILayer      PropertySchemaFieldUI = "LAYER"
	PropertySchemaFieldUIMultiline  PropertySchemaFieldUI = "MULTILINE"
	PropertySchemaFieldUISelection  PropertySchemaFieldUI = "SELECTION"
	PropertySchemaFieldUIColor      PropertySchemaFieldUI = "COLOR"
	PropertySchemaFieldUIRange      PropertySchemaFieldUI = "RANGE"
	PropertySchemaFieldUISlider     PropertySchemaFieldUI = "SLIDER"
	PropertySchemaFieldUIImage      PropertySchemaFieldUI = "IMAGE"
	PropertySchemaFieldUIVideo      PropertySchemaFieldUI = "VIDEO"
	PropertySchemaFieldUIFile       PropertySchemaFieldUI = "FILE"
	PropertySchemaFieldUICameraPose PropertySchemaFieldUI = "CAMERA_POSE"
	PropertySchemaFieldUIDatetime   PropertySchemaFieldUI = "DATETIME"
)

var AllPropertySchemaFieldUI = []PropertySchemaFieldUI{
	PropertySchemaFieldUILayer,
	PropertySchemaFieldUIMultiline,
	PropertySchemaFieldUISelection,
	PropertySchemaFieldUIColor,
	PropertySchemaFieldUIRange,
	PropertySchemaFieldUISlider,
	PropertySchemaFieldUIImage,
	PropertySchemaFieldUIVideo,
	PropertySchemaFieldUIFile,
	PropertySchemaFieldUICameraPose,
	PropertySchemaFieldUIDatetime,
}

func (e PropertySchemaFieldUI) IsValid() bool {
	switch e {
	case PropertySchemaFieldUILayer, PropertySchemaFieldUIMultiline, PropertySchemaFieldUISelection, PropertySchemaFieldUIColor, PropertySchemaFieldUIRange, PropertySchemaFieldUISlider, PropertySchemaFieldUIImage, PropertySchemaFieldUIVideo, PropertySchemaFieldUIFile, PropertySchemaFieldUICameraPose, PropertySchemaFieldUIDatetime:
		return true
	}
	return false
}

func (e PropertySchemaFieldUI) String() string {
	return string(e)
}

func (e *PropertySchemaFieldUI) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PropertySchemaFieldUI(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PropertySchemaFieldUI", str)
	}
	return nil
}

func (e PropertySchemaFieldUI) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PublishmentStatus string

const (
	PublishmentStatusPublic  PublishmentStatus = "PUBLIC"
	PublishmentStatusLimited PublishmentStatus = "LIMITED"
	PublishmentStatusPrivate PublishmentStatus = "PRIVATE"
)

var AllPublishmentStatus = []PublishmentStatus{
	PublishmentStatusPublic,
	PublishmentStatusLimited,
	PublishmentStatusPrivate,
}

func (e PublishmentStatus) IsValid() bool {
	switch e {
	case PublishmentStatusPublic, PublishmentStatusLimited, PublishmentStatusPrivate:
		return true
	}
	return false
}

func (e PublishmentStatus) String() string {
	return string(e)
}

func (e *PublishmentStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PublishmentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PublishmentStatus", str)
	}
	return nil
}

func (e PublishmentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Role string

const (
	RoleReader Role = "READER"
	RoleWriter Role = "WRITER"
	RoleOwner  Role = "OWNER"
)

var AllRole = []Role{
	RoleReader,
	RoleWriter,
	RoleOwner,
}

func (e Role) IsValid() bool {
	switch e {
	case RoleReader, RoleWriter, RoleOwner:
		return true
	}
	return false
}

func (e Role) String() string {
	return string(e)
}

func (e *Role) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Role(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Role", str)
	}
	return nil
}

func (e Role) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TextAlign string

const (
	TextAlignLeft       TextAlign = "LEFT"
	TextAlignCenter     TextAlign = "CENTER"
	TextAlignRight      TextAlign = "RIGHT"
	TextAlignJustify    TextAlign = "JUSTIFY"
	TextAlignJustifyAll TextAlign = "JUSTIFY_ALL"
)

var AllTextAlign = []TextAlign{
	TextAlignLeft,
	TextAlignCenter,
	TextAlignRight,
	TextAlignJustify,
	TextAlignJustifyAll,
}

func (e TextAlign) IsValid() bool {
	switch e {
	case TextAlignLeft, TextAlignCenter, TextAlignRight, TextAlignJustify, TextAlignJustifyAll:
		return true
	}
	return false
}

func (e TextAlign) String() string {
	return string(e)
}

func (e *TextAlign) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TextAlign(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TextAlign", str)
	}
	return nil
}

func (e TextAlign) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Theme string

const (
	ThemeDefault Theme = "DEFAULT"
	ThemeLight   Theme = "LIGHT"
	ThemeDark    Theme = "DARK"
)

var AllTheme = []Theme{
	ThemeDefault,
	ThemeLight,
	ThemeDark,
}

func (e Theme) IsValid() bool {
	switch e {
	case ThemeDefault, ThemeLight, ThemeDark:
		return true
	}
	return false
}

func (e Theme) String() string {
	return string(e)
}

func (e *Theme) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Theme(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Theme", str)
	}
	return nil
}

func (e Theme) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ValueType string

const (
	ValueTypeBool         ValueType = "BOOL"
	ValueTypeNumber       ValueType = "NUMBER"
	ValueTypeString       ValueType = "STRING"
	ValueTypeRef          ValueType = "REF"
	ValueTypeURL          ValueType = "URL"
	ValueTypeLatlng       ValueType = "LATLNG"
	ValueTypeLatlngheight ValueType = "LATLNGHEIGHT"
	ValueTypeCamera       ValueType = "CAMERA"
	ValueTypeTypography   ValueType = "TYPOGRAPHY"
	ValueTypeCoordinates  ValueType = "COORDINATES"
	ValueTypePolygon      ValueType = "POLYGON"
	ValueTypeRect         ValueType = "RECT"
)

var AllValueType = []ValueType{
	ValueTypeBool,
	ValueTypeNumber,
	ValueTypeString,
	ValueTypeRef,
	ValueTypeURL,
	ValueTypeLatlng,
	ValueTypeLatlngheight,
	ValueTypeCamera,
	ValueTypeTypography,
	ValueTypeCoordinates,
	ValueTypePolygon,
	ValueTypeRect,
}

func (e ValueType) IsValid() bool {
	switch e {
	case ValueTypeBool, ValueTypeNumber, ValueTypeString, ValueTypeRef, ValueTypeURL, ValueTypeLatlng, ValueTypeLatlngheight, ValueTypeCamera, ValueTypeTypography, ValueTypeCoordinates, ValueTypePolygon, ValueTypeRect:
		return true
	}
	return false
}

func (e ValueType) String() string {
	return string(e)
}

func (e *ValueType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValueType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValueType", str)
	}
	return nil
}

func (e ValueType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Visualizer string

const (
	VisualizerCesium Visualizer = "CESIUM"
)

var AllVisualizer = []Visualizer{
	VisualizerCesium,
}

func (e Visualizer) IsValid() bool {
	switch e {
	case VisualizerCesium:
		return true
	}
	return false
}

func (e Visualizer) String() string {
	return string(e)
}

func (e *Visualizer) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Visualizer(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Visualizer", str)
	}
	return nil
}

func (e Visualizer) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WidgetAreaAlign string

const (
	WidgetAreaAlignStart    WidgetAreaAlign = "START"
	WidgetAreaAlignCentered WidgetAreaAlign = "CENTERED"
	WidgetAreaAlignEnd      WidgetAreaAlign = "END"
)

var AllWidgetAreaAlign = []WidgetAreaAlign{
	WidgetAreaAlignStart,
	WidgetAreaAlignCentered,
	WidgetAreaAlignEnd,
}

func (e WidgetAreaAlign) IsValid() bool {
	switch e {
	case WidgetAreaAlignStart, WidgetAreaAlignCentered, WidgetAreaAlignEnd:
		return true
	}
	return false
}

func (e WidgetAreaAlign) String() string {
	return string(e)
}

func (e *WidgetAreaAlign) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WidgetAreaAlign(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WidgetAreaAlign", str)
	}
	return nil
}

func (e WidgetAreaAlign) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WidgetAreaType string

const (
	WidgetAreaTypeTop    WidgetAreaType = "TOP"
	WidgetAreaTypeMiddle WidgetAreaType = "MIDDLE"
	WidgetAreaTypeBottom WidgetAreaType = "BOTTOM"
)

var AllWidgetAreaType = []WidgetAreaType{
	WidgetAreaTypeTop,
	WidgetAreaTypeMiddle,
	WidgetAreaTypeBottom,
}

func (e WidgetAreaType) IsValid() bool {
	switch e {
	case WidgetAreaTypeTop, WidgetAreaTypeMiddle, WidgetAreaTypeBottom:
		return true
	}
	return false
}

func (e WidgetAreaType) String() string {
	return string(e)
}

func (e *WidgetAreaType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WidgetAreaType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WidgetAreaType", str)
	}
	return nil
}

func (e WidgetAreaType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WidgetSectionType string

const (
	WidgetSectionTypeLeft   WidgetSectionType = "LEFT"
	WidgetSectionTypeCenter WidgetSectionType = "CENTER"
	WidgetSectionTypeRight  WidgetSectionType = "RIGHT"
)

var AllWidgetSectionType = []WidgetSectionType{
	WidgetSectionTypeLeft,
	WidgetSectionTypeCenter,
	WidgetSectionTypeRight,
}

func (e WidgetSectionType) IsValid() bool {
	switch e {
	case WidgetSectionTypeLeft, WidgetSectionTypeCenter, WidgetSectionTypeRight:
		return true
	}
	return false
}

func (e WidgetSectionType) String() string {
	return string(e)
}

func (e *WidgetSectionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WidgetSectionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WidgetSectionType", str)
	}
	return nil
}

func (e WidgetSectionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WidgetZoneType string

const (
	WidgetZoneTypeInner WidgetZoneType = "INNER"
	WidgetZoneTypeOuter WidgetZoneType = "OUTER"
)

var AllWidgetZoneType = []WidgetZoneType{
	WidgetZoneTypeInner,
	WidgetZoneTypeOuter,
}

func (e WidgetZoneType) IsValid() bool {
	switch e {
	case WidgetZoneTypeInner, WidgetZoneTypeOuter:
		return true
	}
	return false
}

func (e WidgetZoneType) String() string {
	return string(e)
}

func (e *WidgetZoneType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WidgetZoneType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WidgetZoneType", str)
	}
	return nil
}

func (e WidgetZoneType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
