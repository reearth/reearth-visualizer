package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"unicode"
)

// CollectKeysFromJSON recursively collects keys from a nested JSON object.
// Only collects keys that contain "message" and "description".
func CollectKeysFromJSON(data map[string]interface{}, parentKey string) []string {
	var keys []string
	for k, v := range data {
		fullKey := k
		if parentKey != "" {
			fullKey = parentKey + "." + k
		}

		// If the current key is a map, check if it contains "message" and "description"
		if nested, ok := v.(map[string]interface{}); ok {
			if _, hasMessage := nested["message"]; hasMessage {
				if _, hasDescription := nested["description"]; hasDescription {
					keys = append(keys, fullKey)
				}
			}
			// Recurse into nested maps
			keys = append(keys, CollectKeysFromJSON(nested, fullKey)...)
		}
	}
	return keys
}

// toCamelCase converts a dot-delimited key to CamelCase, ensuring proper conversion for snake_case parts.
func toCamelCase(input string) string {
	parts := strings.Split(input, ".")
	for i, part := range parts {
		parts[i] = convertToCamel(part)
	}
	return strings.Join(parts, "")
}

// convertToCamel converts a single part to CamelCase (e.g., "not_found" -> "NotFound").
func convertToCamel(part string) string {
	subParts := strings.Split(part, "_") // Split by underscores
	for i, sub := range subParts {
		subParts[i] = capitalize(sub)
	}
	return strings.Join(subParts, "") // Combine sub-parts into a single CamelCase string
}

// capitalize makes the first letter of a string uppercase.
func capitalize(s string) string {
	if len(s) == 0 {
		return s
	}
	return string(unicode.ToUpper(rune(s[0]))) + s[1:]
}

func main() {
	jsonFile := "en/error.json"
	outputFile := "errorkeys_gen.go"

	file, err := os.Open(jsonFile)
	if err != nil {
		panic(err)
	}
	defer func() {
		if err := file.Close(); err != nil {
			panic(err)
		}
	}()

	var data map[string]interface{}
	if err := json.NewDecoder(file).Decode(&data); err != nil {
		panic(err)
	}

	// collect keys from JSON
	keys := CollectKeysFromJSON(data, "")

	// generate constants
	var buf bytes.Buffer
	buf.WriteString("// Code generated by go generate; DO NOT EDIT.\n")
	buf.WriteString("package locales\n\n")
	// here we don't include `type ErrorKey string`
	buf.WriteString("const (\n")
	for _, key := range keys {
		constName := "ErrKey" + toCamelCase(key)
		buf.WriteString(fmt.Sprintf("\t%s ErrorKey = \"%s\"\n", constName, key))
	}
	buf.WriteString(")\n")

	// write to file
	if err := os.WriteFile(outputFile, buf.Bytes(), 0644); err != nil {
		panic(err)
	}

	fmt.Println("Generated file:", outputFile)
}
