// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlmodel

import (
	"fmt"
	"io"
	"net/url"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/reearth/reearthx/usecasex"
	"golang.org/x/text/language"
)

type Geometry interface {
	IsGeometry()
}

type NLSLayer interface {
	IsNLSLayer()
	GetID() ID
	GetIndex() *int
	GetLayerType() string
	GetSceneID() ID
	GetConfig() JSON
	GetTitle() string
	GetVisible() bool
	GetInfobox() *NLSInfobox
	GetPhotoOverlay() *NLSPhotoOverlay
	GetIsSketch() bool
	GetSketch() *SketchInfo
}

type Node interface {
	IsNode()
	GetID() ID
}

type PropertyItem interface {
	IsPropertyItem()
}

type AddGeoJSONFeatureInput struct {
	Type       string `json:"type"`
	Geometry   JSON   `json:"geometry"`
	Properties JSON   `json:"properties,omitempty"`
	LayerID    ID     `json:"layerId"`
}

type AddMemberToTeamInput struct {
	TeamID ID   `json:"teamId"`
	UserID ID   `json:"userId"`
	Role   Role `json:"role"`
}

type AddMemberToTeamPayload struct {
	Team *Team `json:"team"`
}

type AddNLSInfoboxBlockInput struct {
	LayerID     ID   `json:"layerId"`
	PluginID    ID   `json:"pluginId"`
	ExtensionID ID   `json:"extensionId"`
	Index       *int `json:"index,omitempty"`
}

type AddNLSInfoboxBlockPayload struct {
	InfoboxBlock *InfoboxBlock `json:"infoboxBlock"`
	Layer        NLSLayer      `json:"layer"`
}

type AddNLSLayerSimpleInput struct {
	LayerType string `json:"layerType"`
	Title     string `json:"title"`
	SceneID   ID     `json:"sceneId"`
	Config    JSON   `json:"config,omitempty"`
	Index     *int   `json:"index,omitempty"`
	Visible   *bool  `json:"visible,omitempty"`
	Schema    JSON   `json:"schema,omitempty"`
}

type AddNLSLayerSimplePayload struct {
	Layers *NLSLayerSimple `json:"layers"`
}

type AddPropertyItemInput struct {
	PropertyID     ID         `json:"propertyId"`
	SchemaGroupID  ID         `json:"schemaGroupId"`
	Index          *int       `json:"index,omitempty"`
	NameFieldValue any        `json:"nameFieldValue,omitempty"`
	NameFieldType  *ValueType `json:"nameFieldType,omitempty"`
}

type AddStyleInput struct {
	SceneID ID     `json:"sceneId"`
	Name    string `json:"name"`
	Value   JSON   `json:"value"`
}

type AddStylePayload struct {
	Style *Style `json:"style"`
}

type AddWidgetInput struct {
	SceneID     ID `json:"sceneId"`
	PluginID    ID `json:"pluginId"`
	ExtensionID ID `json:"extensionId"`
}

type AddWidgetPayload struct {
	Scene       *Scene       `json:"scene"`
	SceneWidget *SceneWidget `json:"sceneWidget"`
}

type Asset struct {
	ID          ID        `json:"id"`
	CreatedAt   time.Time `json:"createdAt"`
	TeamID      ID        `json:"teamId"`
	ProjectID   *ID       `json:"projectId,omitempty"`
	Name        string    `json:"name"`
	Size        int64     `json:"size"`
	URL         string    `json:"url"`
	ContentType string    `json:"contentType"`
	Team        *Team     `json:"team,omitempty"`
	CoreSupport bool      `json:"coreSupport"`
}

func (Asset) IsNode()        {}
func (this Asset) GetID() ID { return this.ID }

type AssetConnection struct {
	Edges      []*AssetEdge `json:"edges"`
	Nodes      []*Asset     `json:"nodes"`
	PageInfo   *PageInfo    `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

type AssetEdge struct {
	Cursor usecasex.Cursor `json:"cursor"`
	Node   *Asset          `json:"node,omitempty"`
}

type AssetSort struct {
	Field     AssetSortField `json:"field"`
	Direction SortDirection  `json:"direction"`
}

type Camera struct {
	Lat      float64 `json:"lat"`
	Lng      float64 `json:"lng"`
	Altitude float64 `json:"altitude"`
	Heading  float64 `json:"heading"`
	Pitch    float64 `json:"pitch"`
	Roll     float64 `json:"roll"`
	Fov      float64 `json:"fov"`
}

type ChangeCustomPropertyTitleInput struct {
	LayerID  ID     `json:"layerId"`
	Schema   JSON   `json:"schema,omitempty"`
	OldTitle string `json:"oldTitle"`
	NewTitle string `json:"newTitle"`
}

type CreateAssetInput struct {
	TeamID      ID             `json:"teamId"`
	ProjectID   *ID            `json:"projectId,omitempty"`
	CoreSupport bool           `json:"coreSupport"`
	File        graphql.Upload `json:"file"`
}

type CreateAssetPayload struct {
	Asset *Asset `json:"asset"`
}

type CreateNLSInfoboxInput struct {
	LayerID ID `json:"layerId"`
}

type CreateNLSInfoboxPayload struct {
	Layer NLSLayer `json:"layer"`
}

type CreateNLSPhotoOverlayInput struct {
	LayerID ID `json:"layerId"`
}

type CreateNLSPhotoOverlayPayload struct {
	Layer NLSLayer `json:"layer"`
}

type CreateProjectInput struct {
	TeamID      ID         `json:"teamId"`
	Visualizer  Visualizer `json:"visualizer"`
	Name        *string    `json:"name,omitempty"`
	Description *string    `json:"description,omitempty"`
	ImageURL    *url.URL   `json:"imageUrl,omitempty"`
	Alias       *string    `json:"alias,omitempty"`
	Archived    *bool      `json:"archived,omitempty"`
	CoreSupport *bool      `json:"coreSupport,omitempty"`
}

type CreateSceneInput struct {
	ProjectID ID `json:"projectId"`
}

type CreateScenePayload struct {
	Scene *Scene `json:"scene"`
}

type CreateStoryBlockInput struct {
	StoryID     ID   `json:"storyId"`
	PageID      ID   `json:"pageId"`
	PluginID    ID   `json:"pluginId"`
	ExtensionID ID   `json:"extensionId"`
	Index       *int `json:"index,omitempty"`
}

type CreateStoryBlockPayload struct {
	Block *StoryBlock `json:"block"`
	Page  *StoryPage  `json:"page"`
	Story *Story      `json:"story"`
	Index int         `json:"index"`
}

type CreateStoryInput struct {
	SceneID ID     `json:"sceneId"`
	Title   string `json:"title"`
	Index   *int   `json:"index,omitempty"`
}

type CreateStoryPageInput struct {
	SceneID         ID      `json:"sceneId"`
	StoryID         ID      `json:"storyId"`
	Title           *string `json:"title,omitempty"`
	Swipeable       *bool   `json:"swipeable,omitempty"`
	Layers          []ID    `json:"layers,omitempty"`
	SwipeableLayers []ID    `json:"swipeableLayers,omitempty"`
	Index           *int    `json:"index,omitempty"`
}

type CreateTeamInput struct {
	Name string `json:"name"`
}

type CreateTeamPayload struct {
	Team *Team `json:"team"`
}

type DeleteGeoJSONFeatureInput struct {
	FeatureID ID `json:"featureId"`
	LayerID   ID `json:"layerId"`
}

type DeleteGeoJSONFeaturePayload struct {
	DeletedFeatureID ID `json:"deletedFeatureId"`
}

type DeleteMeInput struct {
	UserID ID `json:"userId"`
}

type DeleteMePayload struct {
	UserID ID `json:"userId"`
}

type DeleteProjectInput struct {
	ProjectID ID `json:"projectId"`
}

type DeleteProjectPayload struct {
	ProjectID ID `json:"projectId"`
}

type DeleteStoryInput struct {
	SceneID ID `json:"sceneId"`
	StoryID ID `json:"storyId"`
}

type DeleteStoryPageInput struct {
	SceneID ID `json:"sceneId"`
	StoryID ID `json:"storyId"`
	PageID  ID `json:"pageId"`
}

type DeleteStoryPagePayload struct {
	PageID ID     `json:"pageId"`
	Story  *Story `json:"story"`
}

type DeleteStoryPayload struct {
	StoryID ID `json:"storyId"`
}

type DeleteTeamInput struct {
	TeamID ID `json:"teamId"`
}

type DeleteTeamPayload struct {
	TeamID ID `json:"teamId"`
}

type DuplicateNLSLayerInput struct {
	LayerID ID `json:"layerId"`
}

type DuplicateNLSLayerPayload struct {
	Layer NLSLayer `json:"layer"`
}

type DuplicateStoryPageInput struct {
	SceneID ID `json:"sceneId"`
	StoryID ID `json:"storyId"`
	PageID  ID `json:"pageId"`
}

type DuplicateStyleInput struct {
	StyleID ID `json:"styleId"`
}

type DuplicateStylePayload struct {
	Style *Style `json:"style"`
}

type ExportProjectInput struct {
	ProjectID ID `json:"projectId"`
}

type ExportProjectPayload struct {
	ProjectDataPath string `json:"projectDataPath"`
}

type Feature struct {
	Type       string   `json:"type"`
	Geometry   Geometry `json:"geometry"`
	ID         ID       `json:"id"`
	Properties JSON     `json:"properties,omitempty"`
}

type FeatureCollection struct {
	Type     string     `json:"type"`
	Features []*Feature `json:"features"`
}

type GeometryCollection struct {
	Type       string     `json:"type"`
	Geometries []Geometry `json:"geometries"`
}

func (GeometryCollection) IsGeometry() {}

type ImportProjectInput struct {
	TeamID ID             `json:"teamId"`
	File   graphql.Upload `json:"file"`
}

type ImportProjectPayload struct {
	ProjectData JSON `json:"projectData"`
}

type InfoboxBlock struct {
	ID          ID               `json:"id"`
	SceneID     ID               `json:"sceneId"`
	LayerID     ID               `json:"layerId"`
	PropertyID  ID               `json:"propertyId"`
	Property    *Property        `json:"property,omitempty"`
	PluginID    ID               `json:"pluginId"`
	Plugin      *Plugin          `json:"plugin,omitempty"`
	ExtensionID ID               `json:"extensionId"`
	Extension   *PluginExtension `json:"extension,omitempty"`
	Scene       *Scene           `json:"scene,omitempty"`
}

type InstallPluginInput struct {
	SceneID  ID `json:"sceneId"`
	PluginID ID `json:"pluginId"`
}

type InstallPluginPayload struct {
	Scene       *Scene       `json:"scene"`
	ScenePlugin *ScenePlugin `json:"scenePlugin"`
}

type LatLng struct {
	Lat float64 `json:"lat"`
	Lng float64 `json:"lng"`
}

type LatLngHeight struct {
	Lat    float64 `json:"lat"`
	Lng    float64 `json:"lng"`
	Height float64 `json:"height"`
}

type LineString struct {
	Type                  string      `json:"type"`
	LineStringCoordinates [][]float64 `json:"lineStringCoordinates"`
}

func (LineString) IsGeometry() {}

type Me struct {
	ID       ID           `json:"id"`
	Name     string       `json:"name"`
	Email    string       `json:"email"`
	Lang     language.Tag `json:"lang"`
	Theme    Theme        `json:"theme"`
	MyTeamID ID           `json:"myTeamId"`
	Auths    []string     `json:"auths"`
	Teams    []*Team      `json:"teams"`
	MyTeam   *Team        `json:"myTeam,omitempty"`
}

type MergedProperty struct {
	OriginalID *ID                    `json:"originalId,omitempty"`
	ParentID   *ID                    `json:"parentId,omitempty"`
	SchemaID   *ID                    `json:"schemaId,omitempty"`
	Original   *Property              `json:"original,omitempty"`
	Parent     *Property              `json:"parent,omitempty"`
	Schema     *PropertySchema        `json:"schema,omitempty"`
	Groups     []*MergedPropertyGroup `json:"groups"`
}

type MergedPropertyField struct {
	SchemaID   ID                   `json:"schemaId"`
	FieldID    ID                   `json:"fieldId"`
	Value      any                  `json:"value,omitempty"`
	Type       ValueType            `json:"type"`
	Overridden bool                 `json:"overridden"`
	Schema     *PropertySchema      `json:"schema,omitempty"`
	Field      *PropertySchemaField `json:"field,omitempty"`
}

type MergedPropertyGroup struct {
	OriginalPropertyID *ID                    `json:"originalPropertyId,omitempty"`
	ParentPropertyID   *ID                    `json:"parentPropertyId,omitempty"`
	OriginalID         *ID                    `json:"originalId,omitempty"`
	ParentID           *ID                    `json:"parentId,omitempty"`
	SchemaGroupID      ID                     `json:"schemaGroupId"`
	SchemaID           *ID                    `json:"schemaId,omitempty"`
	Fields             []*MergedPropertyField `json:"fields"`
	Groups             []*MergedPropertyGroup `json:"groups"`
	OriginalProperty   *Property              `json:"originalProperty,omitempty"`
	ParentProperty     *Property              `json:"parentProperty,omitempty"`
	Original           *PropertyGroup         `json:"original,omitempty"`
	Parent             *PropertyGroup         `json:"parent,omitempty"`
	Schema             *PropertySchema        `json:"schema,omitempty"`
}

type MoveNLSInfoboxBlockInput struct {
	LayerID        ID  `json:"layerId"`
	InfoboxBlockID ID  `json:"infoboxBlockId"`
	Index          int `json:"index"`
}

type MoveNLSInfoboxBlockPayload struct {
	InfoboxBlockID ID       `json:"infoboxBlockId"`
	Layer          NLSLayer `json:"layer"`
	Index          int      `json:"index"`
}

type MovePropertyItemInput struct {
	PropertyID    ID  `json:"propertyId"`
	SchemaGroupID ID  `json:"schemaGroupId"`
	ItemID        ID  `json:"itemId"`
	Index         int `json:"index"`
}

type MoveStoryBlockInput struct {
	StoryID ID  `json:"storyId"`
	PageID  ID  `json:"pageId"`
	BlockID ID  `json:"blockId"`
	Index   int `json:"index"`
}

type MoveStoryBlockPayload struct {
	Page    *StoryPage `json:"page"`
	Story   *Story     `json:"story"`
	BlockID ID         `json:"blockId"`
	Index   int        `json:"index"`
}

type MoveStoryInput struct {
	SceneID ID  `json:"sceneId"`
	StoryID ID  `json:"storyId"`
	Index   int `json:"index"`
}

type MoveStoryPageInput struct {
	StoryID ID  `json:"storyId"`
	PageID  ID  `json:"pageId"`
	Index   int `json:"index"`
}

type MoveStoryPagePayload struct {
	Page  *StoryPage `json:"page"`
	Story *Story     `json:"story"`
	Index int        `json:"index"`
}

type MoveStoryPayload struct {
	StoryID ID       `json:"storyId"`
	Index   int      `json:"index"`
	Stories []*Story `json:"stories"`
}

type MultiPolygon struct {
	Type                    string          `json:"type"`
	MultiPolygonCoordinates [][][][]float64 `json:"multiPolygonCoordinates"`
}

func (MultiPolygon) IsGeometry() {}

type Mutation struct {
}

type NLSInfobox struct {
	ID         ID              `json:"id"`
	SceneID    ID              `json:"sceneId"`
	LayerID    ID              `json:"layerId"`
	PropertyID ID              `json:"propertyId"`
	Blocks     []*InfoboxBlock `json:"blocks"`
	Property   *Property       `json:"property,omitempty"`
	Scene      *Scene          `json:"scene,omitempty"`
}

type NLSLayerGroup struct {
	ID           ID               `json:"id"`
	Index        *int             `json:"index,omitempty"`
	LayerType    string           `json:"layerType"`
	SceneID      ID               `json:"sceneId"`
	Children     []NLSLayer       `json:"children"`
	ChildrenIds  []ID             `json:"childrenIds"`
	Config       JSON             `json:"config,omitempty"`
	Title        string           `json:"title"`
	Visible      bool             `json:"visible"`
	Infobox      *NLSInfobox      `json:"infobox,omitempty"`
	PhotoOverlay *NLSPhotoOverlay `json:"photoOverlay,omitempty"`
	Scene        *Scene           `json:"scene,omitempty"`
	IsSketch     bool             `json:"isSketch"`
	Sketch       *SketchInfo      `json:"sketch,omitempty"`
}

func (NLSLayerGroup) IsNLSLayer()                            {}
func (this NLSLayerGroup) GetID() ID                         { return this.ID }
func (this NLSLayerGroup) GetIndex() *int                    { return this.Index }
func (this NLSLayerGroup) GetLayerType() string              { return this.LayerType }
func (this NLSLayerGroup) GetSceneID() ID                    { return this.SceneID }
func (this NLSLayerGroup) GetConfig() JSON                   { return this.Config }
func (this NLSLayerGroup) GetTitle() string                  { return this.Title }
func (this NLSLayerGroup) GetVisible() bool                  { return this.Visible }
func (this NLSLayerGroup) GetInfobox() *NLSInfobox           { return this.Infobox }
func (this NLSLayerGroup) GetPhotoOverlay() *NLSPhotoOverlay { return this.PhotoOverlay }
func (this NLSLayerGroup) GetIsSketch() bool                 { return this.IsSketch }
func (this NLSLayerGroup) GetSketch() *SketchInfo            { return this.Sketch }

type NLSLayerSimple struct {
	ID           ID               `json:"id"`
	Index        *int             `json:"index,omitempty"`
	LayerType    string           `json:"layerType"`
	SceneID      ID               `json:"sceneId"`
	Config       JSON             `json:"config,omitempty"`
	Title        string           `json:"title"`
	Visible      bool             `json:"visible"`
	Infobox      *NLSInfobox      `json:"infobox,omitempty"`
	PhotoOverlay *NLSPhotoOverlay `json:"photoOverlay,omitempty"`
	Scene        *Scene           `json:"scene,omitempty"`
	IsSketch     bool             `json:"isSketch"`
	Sketch       *SketchInfo      `json:"sketch,omitempty"`
}

func (NLSLayerSimple) IsNLSLayer()                            {}
func (this NLSLayerSimple) GetID() ID                         { return this.ID }
func (this NLSLayerSimple) GetIndex() *int                    { return this.Index }
func (this NLSLayerSimple) GetLayerType() string              { return this.LayerType }
func (this NLSLayerSimple) GetSceneID() ID                    { return this.SceneID }
func (this NLSLayerSimple) GetConfig() JSON                   { return this.Config }
func (this NLSLayerSimple) GetTitle() string                  { return this.Title }
func (this NLSLayerSimple) GetVisible() bool                  { return this.Visible }
func (this NLSLayerSimple) GetInfobox() *NLSInfobox           { return this.Infobox }
func (this NLSLayerSimple) GetPhotoOverlay() *NLSPhotoOverlay { return this.PhotoOverlay }
func (this NLSLayerSimple) GetIsSketch() bool                 { return this.IsSketch }
func (this NLSLayerSimple) GetSketch() *SketchInfo            { return this.Sketch }

type NLSPhotoOverlay struct {
	ID         ID        `json:"id"`
	SceneID    ID        `json:"sceneId"`
	LayerID    ID        `json:"layerId"`
	PropertyID ID        `json:"propertyId"`
	Property   *Property `json:"property,omitempty"`
	Scene      *Scene    `json:"scene,omitempty"`
}

type PageInfo struct {
	StartCursor     *usecasex.Cursor `json:"startCursor,omitempty"`
	EndCursor       *usecasex.Cursor `json:"endCursor,omitempty"`
	HasNextPage     bool             `json:"hasNextPage"`
	HasPreviousPage bool             `json:"hasPreviousPage"`
}

type PageLayerInput struct {
	SceneID   ID    `json:"sceneId"`
	StoryID   ID    `json:"storyId"`
	PageID    ID    `json:"pageId"`
	Swipeable *bool `json:"swipeable,omitempty"`
	LayerID   ID    `json:"layerId"`
}

type Pagination struct {
	First  *int             `json:"first,omitempty"`
	Last   *int             `json:"last,omitempty"`
	After  *usecasex.Cursor `json:"after,omitempty"`
	Before *usecasex.Cursor `json:"before,omitempty"`
}

type Plugin struct {
	ID                       ID                 `json:"id"`
	SceneID                  *ID                `json:"sceneId,omitempty"`
	Name                     string             `json:"name"`
	Version                  string             `json:"version"`
	Description              string             `json:"description"`
	Author                   string             `json:"author"`
	RepositoryURL            string             `json:"repositoryUrl"`
	PropertySchemaID         *ID                `json:"propertySchemaId,omitempty"`
	Extensions               []*PluginExtension `json:"extensions"`
	ScenePlugin              *ScenePlugin       `json:"scenePlugin,omitempty"`
	AllTranslatedDescription map[string]string  `json:"allTranslatedDescription,omitempty"`
	AllTranslatedName        map[string]string  `json:"allTranslatedName,omitempty"`
	Scene                    *Scene             `json:"scene,omitempty"`
	TranslatedName           string             `json:"translatedName"`
	TranslatedDescription    string             `json:"translatedDescription"`
	PropertySchema           *PropertySchema    `json:"propertySchema,omitempty"`
}

type PluginExtension struct {
	ExtensionID              ID                  `json:"extensionId"`
	PluginID                 ID                  `json:"pluginId"`
	Type                     PluginExtensionType `json:"type"`
	Name                     string              `json:"name"`
	Description              string              `json:"description"`
	Icon                     string              `json:"icon"`
	SingleOnly               *bool               `json:"singleOnly,omitempty"`
	WidgetLayout             *WidgetLayout       `json:"widgetLayout,omitempty"`
	Visualizer               *Visualizer         `json:"visualizer,omitempty"`
	PropertySchemaID         ID                  `json:"propertySchemaId"`
	AllTranslatedName        map[string]string   `json:"allTranslatedName,omitempty"`
	AllTranslatedDescription map[string]string   `json:"allTranslatedDescription,omitempty"`
	Plugin                   *Plugin             `json:"plugin,omitempty"`
	SceneWidget              *SceneWidget        `json:"sceneWidget,omitempty"`
	PropertySchema           *PropertySchema     `json:"propertySchema,omitempty"`
	TranslatedName           string              `json:"translatedName"`
	TranslatedDescription    string              `json:"translatedDescription"`
}

type Point struct {
	Type             string    `json:"type"`
	PointCoordinates []float64 `json:"pointCoordinates"`
}

func (Point) IsGeometry() {}

type Policy struct {
	ID                    ID     `json:"id"`
	Name                  string `json:"name"`
	ProjectCount          *int   `json:"projectCount,omitempty"`
	MemberCount           *int   `json:"memberCount,omitempty"`
	PublishedProjectCount *int   `json:"publishedProjectCount,omitempty"`
	LayerCount            *int   `json:"layerCount,omitempty"`
	AssetStorageSize      *int64 `json:"assetStorageSize,omitempty"`
	NlsLayersCount        *int   `json:"nlsLayersCount,omitempty"`
	PageCount             *int   `json:"pageCount,omitempty"`
	BlocksCount           *int   `json:"blocksCount,omitempty"`
}

type Polygon struct {
	Type               string        `json:"type"`
	PolygonCoordinates [][][]float64 `json:"polygonCoordinates"`
}

func (Polygon) IsGeometry() {}

type Project struct {
	ID                ID                `json:"id"`
	IsArchived        bool              `json:"isArchived"`
	IsBasicAuthActive bool              `json:"isBasicAuthActive"`
	BasicAuthUsername string            `json:"basicAuthUsername"`
	BasicAuthPassword string            `json:"basicAuthPassword"`
	CreatedAt         time.Time         `json:"createdAt"`
	UpdatedAt         time.Time         `json:"updatedAt"`
	PublishedAt       *time.Time        `json:"publishedAt,omitempty"`
	Name              string            `json:"name"`
	Description       string            `json:"description"`
	Alias             string            `json:"alias"`
	PublicTitle       string            `json:"publicTitle"`
	PublicDescription string            `json:"publicDescription"`
	PublicImage       string            `json:"publicImage"`
	PublicNoIndex     bool              `json:"publicNoIndex"`
	ImageURL          *url.URL          `json:"imageUrl,omitempty"`
	TeamID            ID                `json:"teamId"`
	Visualizer        Visualizer        `json:"visualizer"`
	PublishmentStatus PublishmentStatus `json:"publishmentStatus"`
	Team              *Team             `json:"team,omitempty"`
	Scene             *Scene            `json:"scene,omitempty"`
	CoreSupport       bool              `json:"coreSupport"`
	EnableGa          bool              `json:"enableGa"`
	TrackingID        string            `json:"trackingId"`
	Starred           bool              `json:"starred"`
	IsDeleted         bool              `json:"isDeleted"`
}

func (Project) IsNode()        {}
func (this Project) GetID() ID { return this.ID }

type ProjectAliasAvailability struct {
	Alias     string `json:"alias"`
	Available bool   `json:"available"`
}

type ProjectConnection struct {
	Edges      []*ProjectEdge `json:"edges"`
	Nodes      []*Project     `json:"nodes"`
	PageInfo   *PageInfo      `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

type ProjectEdge struct {
	Cursor usecasex.Cursor `json:"cursor"`
	Node   *Project        `json:"node,omitempty"`
}

type ProjectPayload struct {
	Project *Project `json:"project"`
}

type ProjectSort struct {
	Field     ProjectSortField `json:"field"`
	Direction SortDirection    `json:"direction"`
}

type Property struct {
	ID       ID              `json:"id"`
	SchemaID ID              `json:"schemaId"`
	Items    []PropertyItem  `json:"items"`
	Schema   *PropertySchema `json:"schema,omitempty"`
	Merged   *MergedProperty `json:"merged,omitempty"`
}

func (Property) IsNode()        {}
func (this Property) GetID() ID { return this.ID }

type PropertyCondition struct {
	FieldID ID        `json:"fieldId"`
	Type    ValueType `json:"type"`
	Value   any       `json:"value,omitempty"`
}

type PropertyField struct {
	ID       string               `json:"id"`
	ParentID ID                   `json:"parentId"`
	SchemaID ID                   `json:"schemaId"`
	FieldID  ID                   `json:"fieldId"`
	Type     ValueType            `json:"type"`
	Value    any                  `json:"value,omitempty"`
	Parent   *Property            `json:"parent,omitempty"`
	Schema   *PropertySchema      `json:"schema,omitempty"`
	Field    *PropertySchemaField `json:"field,omitempty"`
}

type PropertyFieldPayload struct {
	Property      *Property      `json:"property"`
	PropertyField *PropertyField `json:"propertyField,omitempty"`
}

type PropertyGroup struct {
	ID            ID                   `json:"id"`
	SchemaID      ID                   `json:"schemaId"`
	SchemaGroupID ID                   `json:"schemaGroupId"`
	Fields        []*PropertyField     `json:"fields"`
	Schema        *PropertySchema      `json:"schema,omitempty"`
	SchemaGroup   *PropertySchemaGroup `json:"schemaGroup,omitempty"`
}

func (PropertyGroup) IsPropertyItem() {}

type PropertyGroupList struct {
	ID            ID                   `json:"id"`
	SchemaID      ID                   `json:"schemaId"`
	SchemaGroupID ID                   `json:"schemaGroupId"`
	Groups        []*PropertyGroup     `json:"groups"`
	Schema        *PropertySchema      `json:"schema,omitempty"`
	SchemaGroup   *PropertySchemaGroup `json:"schemaGroup,omitempty"`
}

func (PropertyGroupList) IsPropertyItem() {}

type PropertyItemPayload struct {
	Property     *Property    `json:"property"`
	PropertyItem PropertyItem `json:"propertyItem,omitempty"`
}

type PropertyLinkableFields struct {
	SchemaID    ID                   `json:"schemaId"`
	Latlng      *ID                  `json:"latlng,omitempty"`
	URL         *ID                  `json:"url,omitempty"`
	LatlngField *PropertySchemaField `json:"latlngField,omitempty"`
	URLField    *PropertySchemaField `json:"urlField,omitempty"`
	Schema      *PropertySchema      `json:"schema,omitempty"`
}

type PropertySchema struct {
	ID             ID                      `json:"id"`
	Groups         []*PropertySchemaGroup  `json:"groups"`
	LinkableFields *PropertyLinkableFields `json:"linkableFields"`
}

type PropertySchemaField struct {
	FieldID                  ID                           `json:"fieldId"`
	Type                     ValueType                    `json:"type"`
	Title                    string                       `json:"title"`
	Description              string                       `json:"description"`
	Prefix                   *string                      `json:"prefix,omitempty"`
	Suffix                   *string                      `json:"suffix,omitempty"`
	DefaultValue             any                          `json:"defaultValue,omitempty"`
	UI                       *PropertySchemaFieldUI       `json:"ui,omitempty"`
	Min                      *float64                     `json:"min,omitempty"`
	Max                      *float64                     `json:"max,omitempty"`
	Placeholder              string                       `json:"placeholder"`
	Choices                  []*PropertySchemaFieldChoice `json:"choices,omitempty"`
	IsAvailableIf            *PropertyCondition           `json:"isAvailableIf,omitempty"`
	AllTranslatedTitle       map[string]string            `json:"allTranslatedTitle,omitempty"`
	AllTranslatedDescription map[string]string            `json:"allTranslatedDescription,omitempty"`
	AllTranslatedPlaceholder map[string]string            `json:"allTranslatedPlaceholder,omitempty"`
	TranslatedTitle          string                       `json:"translatedTitle"`
	TranslatedDescription    string                       `json:"translatedDescription"`
	TranslatedPlaceholder    string                       `json:"translatedPlaceholder"`
}

type PropertySchemaFieldChoice struct {
	Key                string            `json:"key"`
	Title              string            `json:"title"`
	Icon               *string           `json:"icon,omitempty"`
	AllTranslatedTitle map[string]string `json:"allTranslatedTitle,omitempty"`
	TranslatedTitle    string            `json:"translatedTitle"`
}

type PropertySchemaGroup struct {
	SchemaGroupID         ID                     `json:"schemaGroupId"`
	SchemaID              ID                     `json:"schemaId"`
	Fields                []*PropertySchemaField `json:"fields"`
	Collection            *string                `json:"collection,omitempty"`
	IsList                bool                   `json:"isList"`
	IsAvailableIf         *PropertyCondition     `json:"isAvailableIf,omitempty"`
	Title                 *string                `json:"title,omitempty"`
	AllTranslatedTitle    map[string]string      `json:"allTranslatedTitle,omitempty"`
	RepresentativeFieldID *ID                    `json:"representativeFieldId,omitempty"`
	RepresentativeField   *PropertySchemaField   `json:"representativeField,omitempty"`
	Schema                *PropertySchema        `json:"schema,omitempty"`
	TranslatedTitle       string                 `json:"translatedTitle"`
}

type PublishProjectInput struct {
	ProjectID ID                `json:"projectId"`
	Alias     *string           `json:"alias,omitempty"`
	Status    PublishmentStatus `json:"status"`
}

type PublishStoryInput struct {
	StoryID ID                `json:"storyId"`
	Alias   *string           `json:"alias,omitempty"`
	Status  PublishmentStatus `json:"status"`
}

type Query struct {
}

type Rect struct {
	West  float64 `json:"west"`
	South float64 `json:"south"`
	East  float64 `json:"east"`
	North float64 `json:"north"`
}

type RemoveAssetInput struct {
	AssetID ID `json:"assetId"`
}

type RemoveAssetPayload struct {
	AssetID ID `json:"assetId"`
}

type RemoveCustomPropertyInput struct {
	LayerID      ID     `json:"layerId"`
	Schema       JSON   `json:"schema,omitempty"`
	RemovedTitle string `json:"removedTitle"`
}

type RemoveMemberFromTeamInput struct {
	TeamID ID `json:"teamId"`
	UserID ID `json:"userId"`
}

type RemoveMemberFromTeamPayload struct {
	Team *Team `json:"team"`
}

type RemoveMyAuthInput struct {
	Auth string `json:"auth"`
}

type RemoveNLSInfoboxBlockInput struct {
	LayerID        ID `json:"layerId"`
	InfoboxBlockID ID `json:"infoboxBlockId"`
}

type RemoveNLSInfoboxBlockPayload struct {
	InfoboxBlockID ID       `json:"infoboxBlockId"`
	Layer          NLSLayer `json:"layer"`
}

type RemoveNLSInfoboxInput struct {
	LayerID ID `json:"layerId"`
}

type RemoveNLSInfoboxPayload struct {
	Layer NLSLayer `json:"layer"`
}

type RemoveNLSLayerInput struct {
	LayerID ID `json:"layerId"`
}

type RemoveNLSLayerPayload struct {
	LayerID ID `json:"layerId"`
}

type RemoveNLSPhotoOverlayInput struct {
	LayerID ID `json:"layerId"`
}

type RemoveNLSPhotoOverlayPayload struct {
	Layer NLSLayer `json:"layer"`
}

type RemovePropertyFieldInput struct {
	PropertyID    ID  `json:"propertyId"`
	SchemaGroupID *ID `json:"schemaGroupId,omitempty"`
	ItemID        *ID `json:"itemId,omitempty"`
	FieldID       ID  `json:"fieldId"`
}

type RemovePropertyItemInput struct {
	PropertyID    ID `json:"propertyId"`
	SchemaGroupID ID `json:"schemaGroupId"`
	ItemID        ID `json:"itemId"`
}

type RemoveStoryBlockInput struct {
	StoryID ID `json:"storyId"`
	PageID  ID `json:"pageId"`
	BlockID ID `json:"blockId"`
}

type RemoveStoryBlockPayload struct {
	BlockID ID         `json:"blockId"`
	Page    *StoryPage `json:"page"`
	Story   *Story     `json:"story"`
}

type RemoveStyleInput struct {
	StyleID ID `json:"styleId"`
}

type RemoveStylePayload struct {
	StyleID ID `json:"styleId"`
}

type RemoveWidgetInput struct {
	SceneID  ID `json:"sceneId"`
	WidgetID ID `json:"widgetId"`
}

type RemoveWidgetPayload struct {
	Scene    *Scene `json:"scene"`
	WidgetID ID     `json:"widgetId"`
}

type Scene struct {
	ID                ID                 `json:"id"`
	ProjectID         ID                 `json:"projectId"`
	TeamID            ID                 `json:"teamId"`
	PropertyID        ID                 `json:"propertyId"`
	CreatedAt         time.Time          `json:"createdAt"`
	UpdatedAt         time.Time          `json:"updatedAt"`
	Widgets           []*SceneWidget     `json:"widgets"`
	Plugins           []*ScenePlugin     `json:"plugins"`
	WidgetAlignSystem *WidgetAlignSystem `json:"widgetAlignSystem,omitempty"`
	Project           *Project           `json:"project,omitempty"`
	Team              *Team              `json:"team,omitempty"`
	Property          *Property          `json:"property,omitempty"`
	NewLayers         []NLSLayer         `json:"newLayers"`
	Stories           []*Story           `json:"stories"`
	Styles            []*Style           `json:"styles"`
}

func (Scene) IsNode()        {}
func (this Scene) GetID() ID { return this.ID }

type ScenePlugin struct {
	PluginID   ID        `json:"pluginId"`
	PropertyID *ID       `json:"propertyId,omitempty"`
	Plugin     *Plugin   `json:"plugin,omitempty"`
	Property   *Property `json:"property,omitempty"`
}

type SceneWidget struct {
	ID          ID               `json:"id"`
	PluginID    ID               `json:"pluginId"`
	ExtensionID ID               `json:"extensionId"`
	PropertyID  ID               `json:"propertyId"`
	Enabled     bool             `json:"enabled"`
	Extended    bool             `json:"extended"`
	Plugin      *Plugin          `json:"plugin,omitempty"`
	Extension   *PluginExtension `json:"extension,omitempty"`
	Property    *Property        `json:"property,omitempty"`
}

type SignupInput struct {
	Lang   *language.Tag `json:"lang,omitempty"`
	Theme  *Theme        `json:"theme,omitempty"`
	UserID *ID           `json:"userId,omitempty"`
	TeamID *ID           `json:"teamId,omitempty"`
	Secret *string       `json:"secret,omitempty"`
}

type SignupPayload struct {
	User *User `json:"user"`
	Team *Team `json:"team"`
}

type SketchInfo struct {
	CustomPropertySchema JSON               `json:"customPropertySchema,omitempty"`
	FeatureCollection    *FeatureCollection `json:"featureCollection,omitempty"`
}

type Spacing struct {
	Top    float64 `json:"top"`
	Bottom float64 `json:"bottom"`
	Left   float64 `json:"left"`
	Right  float64 `json:"right"`
}

type Story struct {
	ID                ID                `json:"id"`
	Title             string            `json:"title"`
	Alias             string            `json:"alias"`
	PropertyID        ID                `json:"propertyId"`
	Property          *Property         `json:"property,omitempty"`
	Pages             []*StoryPage      `json:"pages"`
	PublishmentStatus PublishmentStatus `json:"publishmentStatus"`
	CreatedAt         time.Time         `json:"createdAt"`
	UpdatedAt         time.Time         `json:"updatedAt"`
	PublishedAt       *time.Time        `json:"publishedAt,omitempty"`
	SceneID           ID                `json:"sceneId"`
	Scene             *Scene            `json:"scene,omitempty"`
	PanelPosition     Position          `json:"panelPosition"`
	BgColor           *string           `json:"bgColor,omitempty"`
	IsBasicAuthActive bool              `json:"isBasicAuthActive"`
	BasicAuthUsername string            `json:"basicAuthUsername"`
	BasicAuthPassword string            `json:"basicAuthPassword"`
	PublicTitle       string            `json:"publicTitle"`
	PublicDescription string            `json:"publicDescription"`
	PublicImage       string            `json:"publicImage"`
	PublicNoIndex     bool              `json:"publicNoIndex"`
	EnableGa          bool              `json:"enableGa"`
	TrackingID        string            `json:"trackingId"`
}

func (Story) IsNode()        {}
func (this Story) GetID() ID { return this.ID }

type StoryBlock struct {
	ID          ID               `json:"id"`
	PluginID    ID               `json:"pluginId"`
	Plugin      *Plugin          `json:"plugin,omitempty"`
	ExtensionID ID               `json:"extensionId"`
	Extension   *PluginExtension `json:"extension,omitempty"`
	PropertyID  ID               `json:"propertyId"`
	Property    *Property        `json:"property,omitempty"`
}

func (StoryBlock) IsNode()        {}
func (this StoryBlock) GetID() ID { return this.ID }

type StoryPage struct {
	ID                 ID            `json:"id"`
	Title              string        `json:"title"`
	Blocks             []*StoryBlock `json:"blocks"`
	Swipeable          bool          `json:"swipeable"`
	LayersIds          []ID          `json:"layersIds"`
	SwipeableLayersIds []ID          `json:"swipeableLayersIds,omitempty"`
	PropertyID         ID            `json:"propertyId"`
	Property           *Property     `json:"property,omitempty"`
	CreatedAt          time.Time     `json:"createdAt"`
	SceneID            ID            `json:"sceneId"`
	Scene              *Scene        `json:"scene,omitempty"`
}

func (StoryPage) IsNode()        {}
func (this StoryPage) GetID() ID { return this.ID }

type StoryPagePayload struct {
	Page  *StoryPage `json:"page"`
	Story *Story     `json:"story"`
}

type StoryPayload struct {
	Story *Story `json:"story"`
}

type Style struct {
	ID      ID     `json:"id"`
	Name    string `json:"name"`
	Value   JSON   `json:"value"`
	SceneID ID     `json:"sceneId"`
	Scene   *Scene `json:"scene,omitempty"`
}

type Team struct {
	ID       ID                 `json:"id"`
	Name     string             `json:"name"`
	Members  []*TeamMember      `json:"members"`
	Personal bool               `json:"personal"`
	PolicyID *ID                `json:"policyId,omitempty"`
	Policy   *Policy            `json:"policy,omitempty"`
	Assets   *AssetConnection   `json:"assets"`
	Projects *ProjectConnection `json:"projects"`
}

func (Team) IsNode()        {}
func (this Team) GetID() ID { return this.ID }

type TeamMember struct {
	UserID ID    `json:"userId"`
	Role   Role  `json:"role"`
	User   *User `json:"user,omitempty"`
}

type Timeline struct {
	CurrentTime *string `json:"currentTime,omitempty"`
	StartTime   *string `json:"startTime,omitempty"`
	EndTime     *string `json:"endTime,omitempty"`
}

type Typography struct {
	FontFamily *string    `json:"fontFamily,omitempty"`
	FontWeight *string    `json:"fontWeight,omitempty"`
	FontSize   *int       `json:"fontSize,omitempty"`
	Color      *string    `json:"color,omitempty"`
	TextAlign  *TextAlign `json:"textAlign,omitempty"`
	Bold       *bool      `json:"bold,omitempty"`
	Italic     *bool      `json:"italic,omitempty"`
	Underline  *bool      `json:"underline,omitempty"`
}

type UninstallPluginInput struct {
	SceneID  ID `json:"sceneId"`
	PluginID ID `json:"pluginId"`
}

type UninstallPluginPayload struct {
	PluginID ID     `json:"pluginId"`
	Scene    *Scene `json:"scene"`
}

type UnlinkPropertyValueInput struct {
	PropertyID    ID  `json:"propertyId"`
	SchemaGroupID *ID `json:"schemaGroupId,omitempty"`
	ItemID        *ID `json:"itemId,omitempty"`
	FieldID       ID  `json:"fieldId"`
}

type UpdateAssetInput struct {
	AssetID   ID  `json:"assetId"`
	ProjectID *ID `json:"projectId,omitempty"`
}

type UpdateAssetPayload struct {
	AssetID   ID  `json:"assetId"`
	ProjectID *ID `json:"projectId,omitempty"`
}

type UpdateCustomPropertySchemaInput struct {
	LayerID ID   `json:"layerId"`
	Schema  JSON `json:"schema,omitempty"`
}

type UpdateGeoJSONFeatureInput struct {
	FeatureID  ID   `json:"featureId"`
	Geometry   JSON `json:"geometry,omitempty"`
	Properties JSON `json:"properties,omitempty"`
	LayerID    ID   `json:"layerId"`
}

type UpdateMeInput struct {
	Name                 *string       `json:"name,omitempty"`
	Email                *string       `json:"email,omitempty"`
	Lang                 *language.Tag `json:"lang,omitempty"`
	Theme                *Theme        `json:"theme,omitempty"`
	Password             *string       `json:"password,omitempty"`
	PasswordConfirmation *string       `json:"passwordConfirmation,omitempty"`
}

type UpdateMePayload struct {
	Me *Me `json:"me"`
}

type UpdateMemberOfTeamInput struct {
	TeamID ID   `json:"teamId"`
	UserID ID   `json:"userId"`
	Role   Role `json:"role"`
}

type UpdateMemberOfTeamPayload struct {
	Team *Team `json:"team"`
}

type UpdateNLSLayerInput struct {
	Index   *int    `json:"index,omitempty"`
	LayerID ID      `json:"layerId"`
	Name    *string `json:"name,omitempty"`
	Visible *bool   `json:"visible,omitempty"`
	Config  JSON    `json:"config,omitempty"`
}

type UpdateNLSLayerPayload struct {
	Layer NLSLayer `json:"layer"`
}

type UpdateNLSLayersInput struct {
	Layers []*UpdateNLSLayerInput `json:"layers"`
}

type UpdateNLSLayersPayload struct {
	Layers []NLSLayer `json:"layers"`
}

type UpdateProjectInput struct {
	ProjectID         ID       `json:"projectId"`
	Name              *string  `json:"name,omitempty"`
	Description       *string  `json:"description,omitempty"`
	Archived          *bool    `json:"archived,omitempty"`
	IsBasicAuthActive *bool    `json:"isBasicAuthActive,omitempty"`
	BasicAuthUsername *string  `json:"basicAuthUsername,omitempty"`
	BasicAuthPassword *string  `json:"basicAuthPassword,omitempty"`
	Alias             *string  `json:"alias,omitempty"`
	ImageURL          *url.URL `json:"imageUrl,omitempty"`
	PublicTitle       *string  `json:"publicTitle,omitempty"`
	PublicDescription *string  `json:"publicDescription,omitempty"`
	PublicImage       *string  `json:"publicImage,omitempty"`
	PublicNoIndex     *bool    `json:"publicNoIndex,omitempty"`
	DeleteImageURL    *bool    `json:"deleteImageUrl,omitempty"`
	DeletePublicImage *bool    `json:"deletePublicImage,omitempty"`
	EnableGa          *bool    `json:"enableGa,omitempty"`
	TrackingID        *string  `json:"trackingId,omitempty"`
	SceneID           *ID      `json:"sceneId,omitempty"`
	Starred           *bool    `json:"starred,omitempty"`
	Deleted           *bool    `json:"deleted,omitempty"`
}

type UpdatePropertyItemInput struct {
	PropertyID    ID                                  `json:"propertyId"`
	SchemaGroupID ID                                  `json:"schemaGroupId"`
	Operations    []*UpdatePropertyItemOperationInput `json:"operations"`
}

type UpdatePropertyItemOperationInput struct {
	Operation      ListOperation `json:"operation"`
	ItemID         *ID           `json:"itemId,omitempty"`
	Index          *int          `json:"index,omitempty"`
	NameFieldValue any           `json:"nameFieldValue,omitempty"`
	NameFieldType  *ValueType    `json:"nameFieldType,omitempty"`
}

type UpdatePropertyValueInput struct {
	PropertyID    ID        `json:"propertyId"`
	SchemaGroupID *ID       `json:"schemaGroupId,omitempty"`
	ItemID        *ID       `json:"itemId,omitempty"`
	FieldID       ID        `json:"fieldId"`
	Value         any       `json:"value,omitempty"`
	Type          ValueType `json:"type"`
}

type UpdateStoryInput struct {
	SceneID           ID        `json:"sceneId"`
	StoryID           ID        `json:"storyId"`
	Title             *string   `json:"title,omitempty"`
	Index             *int      `json:"index,omitempty"`
	PanelPosition     *Position `json:"panelPosition,omitempty"`
	BgColor           *string   `json:"bgColor,omitempty"`
	IsBasicAuthActive *bool     `json:"isBasicAuthActive,omitempty"`
	BasicAuthUsername *string   `json:"basicAuthUsername,omitempty"`
	BasicAuthPassword *string   `json:"basicAuthPassword,omitempty"`
	Alias             *string   `json:"alias,omitempty"`
	PublicTitle       *string   `json:"publicTitle,omitempty"`
	PublicDescription *string   `json:"publicDescription,omitempty"`
	PublicImage       *string   `json:"publicImage,omitempty"`
	PublicNoIndex     *bool     `json:"publicNoIndex,omitempty"`
	DeletePublicImage *bool     `json:"deletePublicImage,omitempty"`
	EnableGa          *bool     `json:"enableGa,omitempty"`
	TrackingID        *string   `json:"trackingId,omitempty"`
}

type UpdateStoryPageInput struct {
	SceneID         ID      `json:"sceneId"`
	StoryID         ID      `json:"storyId"`
	PageID          ID      `json:"pageId"`
	Title           *string `json:"title,omitempty"`
	Swipeable       *bool   `json:"swipeable,omitempty"`
	Layers          []ID    `json:"layers,omitempty"`
	SwipeableLayers []ID    `json:"swipeableLayers,omitempty"`
	Index           *int    `json:"index,omitempty"`
}

type UpdateStyleInput struct {
	StyleID ID      `json:"styleId"`
	Name    *string `json:"name,omitempty"`
	Value   JSON    `json:"value,omitempty"`
}

type UpdateStylePayload struct {
	Style *Style `json:"style"`
}

type UpdateTeamInput struct {
	TeamID ID     `json:"teamId"`
	Name   string `json:"name"`
}

type UpdateTeamPayload struct {
	Team *Team `json:"team"`
}

type UpdateWidgetAlignSystemInput struct {
	SceneID    ID                      `json:"sceneId"`
	Location   *WidgetLocationInput    `json:"location"`
	Align      *WidgetAreaAlign        `json:"align,omitempty"`
	Padding    *WidgetAreaPaddingInput `json:"padding,omitempty"`
	Gap        *int                    `json:"gap,omitempty"`
	Centered   *bool                   `json:"centered,omitempty"`
	Background *string                 `json:"background,omitempty"`
}

type UpdateWidgetAlignSystemPayload struct {
	Scene *Scene `json:"scene"`
}

type UpdateWidgetInput struct {
	SceneID  ID                   `json:"sceneId"`
	WidgetID ID                   `json:"widgetId"`
	Enabled  *bool                `json:"enabled,omitempty"`
	Location *WidgetLocationInput `json:"location,omitempty"`
	Extended *bool                `json:"extended,omitempty"`
	Index    *int                 `json:"index,omitempty"`
}

type UpdateWidgetPayload struct {
	Scene       *Scene       `json:"scene"`
	SceneWidget *SceneWidget `json:"sceneWidget"`
}

type UpgradePluginInput struct {
	SceneID    ID `json:"sceneId"`
	PluginID   ID `json:"pluginId"`
	ToPluginID ID `json:"toPluginId"`
}

type UpgradePluginPayload struct {
	Scene       *Scene       `json:"scene"`
	ScenePlugin *ScenePlugin `json:"scenePlugin"`
}

type UploadFileToPropertyInput struct {
	PropertyID    ID             `json:"propertyId"`
	SchemaGroupID *ID            `json:"schemaGroupId,omitempty"`
	ItemID        *ID            `json:"itemId,omitempty"`
	FieldID       ID             `json:"fieldId"`
	File          graphql.Upload `json:"file"`
}

type UploadPluginInput struct {
	SceneID ID              `json:"sceneId"`
	File    *graphql.Upload `json:"file,omitempty"`
	URL     *url.URL        `json:"url,omitempty"`
}

type UploadPluginPayload struct {
	Plugin      *Plugin      `json:"plugin"`
	Scene       *Scene       `json:"scene"`
	ScenePlugin *ScenePlugin `json:"scenePlugin"`
}

type User struct {
	ID    ID      `json:"id"`
	Name  string  `json:"name"`
	Email string  `json:"email"`
	Host  *string `json:"host,omitempty"`
}

func (User) IsNode()        {}
func (this User) GetID() ID { return this.ID }

type WidgetAlignSystem struct {
	Inner *WidgetZone `json:"inner,omitempty"`
	Outer *WidgetZone `json:"outer,omitempty"`
}

type WidgetArea struct {
	WidgetIds  []ID               `json:"widgetIds"`
	Align      WidgetAreaAlign    `json:"align"`
	Padding    *WidgetAreaPadding `json:"padding,omitempty"`
	Gap        *int               `json:"gap,omitempty"`
	Centered   bool               `json:"centered"`
	Background *string            `json:"background,omitempty"`
}

type WidgetAreaPadding struct {
	Top    int `json:"top"`
	Bottom int `json:"bottom"`
	Left   int `json:"left"`
	Right  int `json:"right"`
}

type WidgetAreaPaddingInput struct {
	Top    int `json:"top"`
	Bottom int `json:"bottom"`
	Left   int `json:"left"`
	Right  int `json:"right"`
}

type WidgetExtendable struct {
	Vertically   bool `json:"vertically"`
	Horizontally bool `json:"horizontally"`
}

type WidgetLayout struct {
	Extendable      *WidgetExtendable `json:"extendable"`
	Extended        bool              `json:"extended"`
	Floating        bool              `json:"floating"`
	DefaultLocation *WidgetLocation   `json:"defaultLocation,omitempty"`
}

type WidgetLocation struct {
	Zone    WidgetZoneType    `json:"zone"`
	Section WidgetSectionType `json:"section"`
	Area    WidgetAreaType    `json:"area"`
}

type WidgetLocationInput struct {
	Zone    WidgetZoneType    `json:"zone"`
	Section WidgetSectionType `json:"section"`
	Area    WidgetAreaType    `json:"area"`
}

type WidgetSection struct {
	Top    *WidgetArea `json:"top,omitempty"`
	Middle *WidgetArea `json:"middle,omitempty"`
	Bottom *WidgetArea `json:"bottom,omitempty"`
}

type WidgetZone struct {
	Left   *WidgetSection `json:"left,omitempty"`
	Center *WidgetSection `json:"center,omitempty"`
	Right  *WidgetSection `json:"right,omitempty"`
}

type AssetSortField string

const (
	AssetSortFieldDate AssetSortField = "DATE"
	AssetSortFieldSize AssetSortField = "SIZE"
	AssetSortFieldName AssetSortField = "NAME"
)

var AllAssetSortField = []AssetSortField{
	AssetSortFieldDate,
	AssetSortFieldSize,
	AssetSortFieldName,
}

func (e AssetSortField) IsValid() bool {
	switch e {
	case AssetSortFieldDate, AssetSortFieldSize, AssetSortFieldName:
		return true
	}
	return false
}

func (e AssetSortField) String() string {
	return string(e)
}

func (e *AssetSortField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AssetSortField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AssetSortField", str)
	}
	return nil
}

func (e AssetSortField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ListOperation string

const (
	ListOperationAdd    ListOperation = "ADD"
	ListOperationMove   ListOperation = "MOVE"
	ListOperationRemove ListOperation = "REMOVE"
)

var AllListOperation = []ListOperation{
	ListOperationAdd,
	ListOperationMove,
	ListOperationRemove,
}

func (e ListOperation) IsValid() bool {
	switch e {
	case ListOperationAdd, ListOperationMove, ListOperationRemove:
		return true
	}
	return false
}

func (e ListOperation) String() string {
	return string(e)
}

func (e *ListOperation) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ListOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ListOperation", str)
	}
	return nil
}

func (e ListOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeType string

const (
	NodeTypeAsset          NodeType = "ASSET"
	NodeTypeUser           NodeType = "USER"
	NodeTypeTeam           NodeType = "TEAM"
	NodeTypeProject        NodeType = "PROJECT"
	NodeTypePlugin         NodeType = "PLUGIN"
	NodeTypeScene          NodeType = "SCENE"
	NodeTypePropertySchema NodeType = "PROPERTY_SCHEMA"
	NodeTypeProperty       NodeType = "PROPERTY"
	NodeTypeLayerGroup     NodeType = "LAYER_GROUP"
	NodeTypeLayerItem      NodeType = "LAYER_ITEM"
)

var AllNodeType = []NodeType{
	NodeTypeAsset,
	NodeTypeUser,
	NodeTypeTeam,
	NodeTypeProject,
	NodeTypePlugin,
	NodeTypeScene,
	NodeTypePropertySchema,
	NodeTypeProperty,
	NodeTypeLayerGroup,
	NodeTypeLayerItem,
}

func (e NodeType) IsValid() bool {
	switch e {
	case NodeTypeAsset, NodeTypeUser, NodeTypeTeam, NodeTypeProject, NodeTypePlugin, NodeTypeScene, NodeTypePropertySchema, NodeTypeProperty, NodeTypeLayerGroup, NodeTypeLayerItem:
		return true
	}
	return false
}

func (e NodeType) String() string {
	return string(e)
}

func (e *NodeType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeType", str)
	}
	return nil
}

func (e NodeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PluginExtensionType string

const (
	PluginExtensionTypePrimitive    PluginExtensionType = "PRIMITIVE"
	PluginExtensionTypeWidget       PluginExtensionType = "WIDGET"
	PluginExtensionTypeBlock        PluginExtensionType = "BLOCK"
	PluginExtensionTypeVisualizer   PluginExtensionType = "VISUALIZER"
	PluginExtensionTypeInfobox      PluginExtensionType = "INFOBOX"
	PluginExtensionTypePhotooverlay PluginExtensionType = "PHOTOOVERLAY"
	PluginExtensionTypeStory        PluginExtensionType = "Story"
	PluginExtensionTypeStoryPage    PluginExtensionType = "StoryPage"
	PluginExtensionTypeStoryBlock   PluginExtensionType = "StoryBlock"
	PluginExtensionTypeInfoboxBlock PluginExtensionType = "InfoboxBlock"
)

var AllPluginExtensionType = []PluginExtensionType{
	PluginExtensionTypePrimitive,
	PluginExtensionTypeWidget,
	PluginExtensionTypeBlock,
	PluginExtensionTypeVisualizer,
	PluginExtensionTypeInfobox,
	PluginExtensionTypePhotooverlay,
	PluginExtensionTypeStory,
	PluginExtensionTypeStoryPage,
	PluginExtensionTypeStoryBlock,
	PluginExtensionTypeInfoboxBlock,
}

func (e PluginExtensionType) IsValid() bool {
	switch e {
	case PluginExtensionTypePrimitive, PluginExtensionTypeWidget, PluginExtensionTypeBlock, PluginExtensionTypeVisualizer, PluginExtensionTypeInfobox, PluginExtensionTypePhotooverlay, PluginExtensionTypeStory, PluginExtensionTypeStoryPage, PluginExtensionTypeStoryBlock, PluginExtensionTypeInfoboxBlock:
		return true
	}
	return false
}

func (e PluginExtensionType) String() string {
	return string(e)
}

func (e *PluginExtensionType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PluginExtensionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PluginExtensionType", str)
	}
	return nil
}

func (e PluginExtensionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Position string

const (
	PositionLeft  Position = "LEFT"
	PositionRight Position = "RIGHT"
)

var AllPosition = []Position{
	PositionLeft,
	PositionRight,
}

func (e Position) IsValid() bool {
	switch e {
	case PositionLeft, PositionRight:
		return true
	}
	return false
}

func (e Position) String() string {
	return string(e)
}

func (e *Position) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Position(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Position", str)
	}
	return nil
}

func (e Position) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectSortField string

const (
	ProjectSortFieldCreatedat ProjectSortField = "CREATEDAT"
	ProjectSortFieldUpdatedat ProjectSortField = "UPDATEDAT"
	ProjectSortFieldName      ProjectSortField = "NAME"
)

var AllProjectSortField = []ProjectSortField{
	ProjectSortFieldCreatedat,
	ProjectSortFieldUpdatedat,
	ProjectSortFieldName,
}

func (e ProjectSortField) IsValid() bool {
	switch e {
	case ProjectSortFieldCreatedat, ProjectSortFieldUpdatedat, ProjectSortFieldName:
		return true
	}
	return false
}

func (e ProjectSortField) String() string {
	return string(e)
}

func (e *ProjectSortField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectSortField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectSortField", str)
	}
	return nil
}

func (e ProjectSortField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PropertySchemaFieldUI string

const (
	PropertySchemaFieldUILayer            PropertySchemaFieldUI = "LAYER"
	PropertySchemaFieldUIMultiline        PropertySchemaFieldUI = "MULTILINE"
	PropertySchemaFieldUISelection        PropertySchemaFieldUI = "SELECTION"
	PropertySchemaFieldUIColor            PropertySchemaFieldUI = "COLOR"
	PropertySchemaFieldUIRange            PropertySchemaFieldUI = "RANGE"
	PropertySchemaFieldUISlider           PropertySchemaFieldUI = "SLIDER"
	PropertySchemaFieldUIImage            PropertySchemaFieldUI = "IMAGE"
	PropertySchemaFieldUIVideo            PropertySchemaFieldUI = "VIDEO"
	PropertySchemaFieldUIFile             PropertySchemaFieldUI = "FILE"
	PropertySchemaFieldUICameraPose       PropertySchemaFieldUI = "CAMERA_POSE"
	PropertySchemaFieldUIDatetime         PropertySchemaFieldUI = "DATETIME"
	PropertySchemaFieldUIMargin           PropertySchemaFieldUI = "MARGIN"
	PropertySchemaFieldUIPadding          PropertySchemaFieldUI = "PADDING"
	PropertySchemaFieldUIZoomlevel        PropertySchemaFieldUI = "ZOOMLEVEL"
	PropertySchemaFieldUIPropertySelector PropertySchemaFieldUI = "PROPERTY_SELECTOR"
)

var AllPropertySchemaFieldUI = []PropertySchemaFieldUI{
	PropertySchemaFieldUILayer,
	PropertySchemaFieldUIMultiline,
	PropertySchemaFieldUISelection,
	PropertySchemaFieldUIColor,
	PropertySchemaFieldUIRange,
	PropertySchemaFieldUISlider,
	PropertySchemaFieldUIImage,
	PropertySchemaFieldUIVideo,
	PropertySchemaFieldUIFile,
	PropertySchemaFieldUICameraPose,
	PropertySchemaFieldUIDatetime,
	PropertySchemaFieldUIMargin,
	PropertySchemaFieldUIPadding,
	PropertySchemaFieldUIZoomlevel,
	PropertySchemaFieldUIPropertySelector,
}

func (e PropertySchemaFieldUI) IsValid() bool {
	switch e {
	case PropertySchemaFieldUILayer, PropertySchemaFieldUIMultiline, PropertySchemaFieldUISelection, PropertySchemaFieldUIColor, PropertySchemaFieldUIRange, PropertySchemaFieldUISlider, PropertySchemaFieldUIImage, PropertySchemaFieldUIVideo, PropertySchemaFieldUIFile, PropertySchemaFieldUICameraPose, PropertySchemaFieldUIDatetime, PropertySchemaFieldUIMargin, PropertySchemaFieldUIPadding, PropertySchemaFieldUIZoomlevel, PropertySchemaFieldUIPropertySelector:
		return true
	}
	return false
}

func (e PropertySchemaFieldUI) String() string {
	return string(e)
}

func (e *PropertySchemaFieldUI) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PropertySchemaFieldUI(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PropertySchemaFieldUI", str)
	}
	return nil
}

func (e PropertySchemaFieldUI) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PublishmentStatus string

const (
	PublishmentStatusPublic  PublishmentStatus = "PUBLIC"
	PublishmentStatusLimited PublishmentStatus = "LIMITED"
	PublishmentStatusPrivate PublishmentStatus = "PRIVATE"
)

var AllPublishmentStatus = []PublishmentStatus{
	PublishmentStatusPublic,
	PublishmentStatusLimited,
	PublishmentStatusPrivate,
}

func (e PublishmentStatus) IsValid() bool {
	switch e {
	case PublishmentStatusPublic, PublishmentStatusLimited, PublishmentStatusPrivate:
		return true
	}
	return false
}

func (e PublishmentStatus) String() string {
	return string(e)
}

func (e *PublishmentStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PublishmentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PublishmentStatus", str)
	}
	return nil
}

func (e PublishmentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Role string

const (
	RoleReader     Role = "READER"
	RoleWriter     Role = "WRITER"
	RoleMaintainer Role = "MAINTAINER"
	RoleOwner      Role = "OWNER"
)

var AllRole = []Role{
	RoleReader,
	RoleWriter,
	RoleMaintainer,
	RoleOwner,
}

func (e Role) IsValid() bool {
	switch e {
	case RoleReader, RoleWriter, RoleMaintainer, RoleOwner:
		return true
	}
	return false
}

func (e Role) String() string {
	return string(e)
}

func (e *Role) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Role(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Role", str)
	}
	return nil
}

func (e Role) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortDirection string

const (
	SortDirectionAsc  SortDirection = "ASC"
	SortDirectionDesc SortDirection = "DESC"
)

var AllSortDirection = []SortDirection{
	SortDirectionAsc,
	SortDirectionDesc,
}

func (e SortDirection) IsValid() bool {
	switch e {
	case SortDirectionAsc, SortDirectionDesc:
		return true
	}
	return false
}

func (e SortDirection) String() string {
	return string(e)
}

func (e *SortDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirection", str)
	}
	return nil
}

func (e SortDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TextAlign string

const (
	TextAlignLeft       TextAlign = "LEFT"
	TextAlignCenter     TextAlign = "CENTER"
	TextAlignRight      TextAlign = "RIGHT"
	TextAlignJustify    TextAlign = "JUSTIFY"
	TextAlignJustifyAll TextAlign = "JUSTIFY_ALL"
)

var AllTextAlign = []TextAlign{
	TextAlignLeft,
	TextAlignCenter,
	TextAlignRight,
	TextAlignJustify,
	TextAlignJustifyAll,
}

func (e TextAlign) IsValid() bool {
	switch e {
	case TextAlignLeft, TextAlignCenter, TextAlignRight, TextAlignJustify, TextAlignJustifyAll:
		return true
	}
	return false
}

func (e TextAlign) String() string {
	return string(e)
}

func (e *TextAlign) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TextAlign(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TextAlign", str)
	}
	return nil
}

func (e TextAlign) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Theme string

const (
	ThemeDefault Theme = "DEFAULT"
	ThemeLight   Theme = "LIGHT"
	ThemeDark    Theme = "DARK"
)

var AllTheme = []Theme{
	ThemeDefault,
	ThemeLight,
	ThemeDark,
}

func (e Theme) IsValid() bool {
	switch e {
	case ThemeDefault, ThemeLight, ThemeDark:
		return true
	}
	return false
}

func (e Theme) String() string {
	return string(e)
}

func (e *Theme) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Theme(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Theme", str)
	}
	return nil
}

func (e Theme) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ValueType string

const (
	ValueTypeBool         ValueType = "BOOL"
	ValueTypeNumber       ValueType = "NUMBER"
	ValueTypeString       ValueType = "STRING"
	ValueTypeRef          ValueType = "REF"
	ValueTypeURL          ValueType = "URL"
	ValueTypeLatlng       ValueType = "LATLNG"
	ValueTypeLatlngheight ValueType = "LATLNGHEIGHT"
	ValueTypeCamera       ValueType = "CAMERA"
	ValueTypeTypography   ValueType = "TYPOGRAPHY"
	ValueTypeCoordinates  ValueType = "COORDINATES"
	ValueTypePolygon      ValueType = "POLYGON"
	ValueTypeRect         ValueType = "RECT"
	ValueTypeSpacing      ValueType = "SPACING"
	ValueTypeArray        ValueType = "ARRAY"
	ValueTypeTimeline     ValueType = "TIMELINE"
)

var AllValueType = []ValueType{
	ValueTypeBool,
	ValueTypeNumber,
	ValueTypeString,
	ValueTypeRef,
	ValueTypeURL,
	ValueTypeLatlng,
	ValueTypeLatlngheight,
	ValueTypeCamera,
	ValueTypeTypography,
	ValueTypeCoordinates,
	ValueTypePolygon,
	ValueTypeRect,
	ValueTypeSpacing,
	ValueTypeArray,
	ValueTypeTimeline,
}

func (e ValueType) IsValid() bool {
	switch e {
	case ValueTypeBool, ValueTypeNumber, ValueTypeString, ValueTypeRef, ValueTypeURL, ValueTypeLatlng, ValueTypeLatlngheight, ValueTypeCamera, ValueTypeTypography, ValueTypeCoordinates, ValueTypePolygon, ValueTypeRect, ValueTypeSpacing, ValueTypeArray, ValueTypeTimeline:
		return true
	}
	return false
}

func (e ValueType) String() string {
	return string(e)
}

func (e *ValueType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValueType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValueType", str)
	}
	return nil
}

func (e ValueType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Visualizer string

const (
	VisualizerCesium Visualizer = "CESIUM"
)

var AllVisualizer = []Visualizer{
	VisualizerCesium,
}

func (e Visualizer) IsValid() bool {
	switch e {
	case VisualizerCesium:
		return true
	}
	return false
}

func (e Visualizer) String() string {
	return string(e)
}

func (e *Visualizer) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Visualizer(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Visualizer", str)
	}
	return nil
}

func (e Visualizer) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WidgetAreaAlign string

const (
	WidgetAreaAlignStart    WidgetAreaAlign = "START"
	WidgetAreaAlignCentered WidgetAreaAlign = "CENTERED"
	WidgetAreaAlignEnd      WidgetAreaAlign = "END"
)

var AllWidgetAreaAlign = []WidgetAreaAlign{
	WidgetAreaAlignStart,
	WidgetAreaAlignCentered,
	WidgetAreaAlignEnd,
}

func (e WidgetAreaAlign) IsValid() bool {
	switch e {
	case WidgetAreaAlignStart, WidgetAreaAlignCentered, WidgetAreaAlignEnd:
		return true
	}
	return false
}

func (e WidgetAreaAlign) String() string {
	return string(e)
}

func (e *WidgetAreaAlign) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WidgetAreaAlign(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WidgetAreaAlign", str)
	}
	return nil
}

func (e WidgetAreaAlign) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WidgetAreaType string

const (
	WidgetAreaTypeTop    WidgetAreaType = "TOP"
	WidgetAreaTypeMiddle WidgetAreaType = "MIDDLE"
	WidgetAreaTypeBottom WidgetAreaType = "BOTTOM"
)

var AllWidgetAreaType = []WidgetAreaType{
	WidgetAreaTypeTop,
	WidgetAreaTypeMiddle,
	WidgetAreaTypeBottom,
}

func (e WidgetAreaType) IsValid() bool {
	switch e {
	case WidgetAreaTypeTop, WidgetAreaTypeMiddle, WidgetAreaTypeBottom:
		return true
	}
	return false
}

func (e WidgetAreaType) String() string {
	return string(e)
}

func (e *WidgetAreaType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WidgetAreaType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WidgetAreaType", str)
	}
	return nil
}

func (e WidgetAreaType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WidgetSectionType string

const (
	WidgetSectionTypeLeft   WidgetSectionType = "LEFT"
	WidgetSectionTypeCenter WidgetSectionType = "CENTER"
	WidgetSectionTypeRight  WidgetSectionType = "RIGHT"
)

var AllWidgetSectionType = []WidgetSectionType{
	WidgetSectionTypeLeft,
	WidgetSectionTypeCenter,
	WidgetSectionTypeRight,
}

func (e WidgetSectionType) IsValid() bool {
	switch e {
	case WidgetSectionTypeLeft, WidgetSectionTypeCenter, WidgetSectionTypeRight:
		return true
	}
	return false
}

func (e WidgetSectionType) String() string {
	return string(e)
}

func (e *WidgetSectionType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WidgetSectionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WidgetSectionType", str)
	}
	return nil
}

func (e WidgetSectionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WidgetZoneType string

const (
	WidgetZoneTypeInner WidgetZoneType = "INNER"
	WidgetZoneTypeOuter WidgetZoneType = "OUTER"
)

var AllWidgetZoneType = []WidgetZoneType{
	WidgetZoneTypeInner,
	WidgetZoneTypeOuter,
}

func (e WidgetZoneType) IsValid() bool {
	switch e {
	case WidgetZoneTypeInner, WidgetZoneTypeOuter:
		return true
	}
	return false
}

func (e WidgetZoneType) String() string {
	return string(e)
}

func (e *WidgetZoneType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WidgetZoneType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WidgetZoneType", str)
	}
	return nil
}

func (e WidgetZoneType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
