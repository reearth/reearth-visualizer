// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlmodel

import (
	"fmt"
	"io"
	"net/url"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/reearth/reearthx/usecasex"
	"golang.org/x/text/language"
)

type Layer interface {
	IsLayer()
	GetID() ID
	GetSceneID() ID
	GetName() string
	GetIsVisible() bool
	GetPropertyID() *ID
	GetPluginID() *ID
	GetExtensionID() *ID
	GetInfobox() *Infobox
	GetParentID() *ID
	GetParent() *LayerGroup
	GetProperty() *Property
	GetPlugin() *Plugin
	GetExtension() *PluginExtension
	GetScenePlugin() *ScenePlugin
	GetTags() []LayerTag
}

type LayerTag interface {
	IsLayerTag()
	GetTagID() ID
	GetTag() Tag
}

type NLSLayer interface {
	IsNLSLayer()
	GetID() ID
	GetLayerType() string
	GetSceneID() ID
	GetConfig() JSON
	GetTitle() string
	GetVisible() bool
	GetInfobox() *NLSInfobox
}

type Node interface {
	IsNode()
	GetID() ID
}

type PropertyItem interface {
	IsPropertyItem()
}

type Tag interface {
	IsTag()
	GetID() ID
	GetSceneID() ID
	GetLabel() string
	GetLayers() []Layer
}

type AddClusterInput struct {
	SceneID ID     `json:"sceneId"`
	Name    string `json:"name"`
}

type AddClusterPayload struct {
	Scene   *Scene   `json:"scene"`
	Cluster *Cluster `json:"cluster"`
}

type AddDatasetSchemaInput struct {
	SceneID             ID     `json:"sceneId"`
	Name                string `json:"name"`
	Representativefield *ID    `json:"representativefield,omitempty"`
}

type AddDatasetSchemaPayload struct {
	DatasetSchema *DatasetSchema `json:"datasetSchema,omitempty"`
}

type AddInfoboxFieldInput struct {
	LayerID     ID   `json:"layerId"`
	PluginID    ID   `json:"pluginId"`
	ExtensionID ID   `json:"extensionId"`
	Index       *int `json:"index,omitempty"`
}

type AddInfoboxFieldPayload struct {
	InfoboxField *InfoboxField `json:"infoboxField"`
	Layer        Layer         `json:"layer"`
}

type AddLayerGroupInput struct {
	ParentLayerID         ID      `json:"parentLayerId"`
	PluginID              *ID     `json:"pluginId,omitempty"`
	ExtensionID           *ID     `json:"extensionId,omitempty"`
	Index                 *int    `json:"index,omitempty"`
	LinkedDatasetSchemaID *ID     `json:"linkedDatasetSchemaID,omitempty"`
	Name                  *string `json:"name,omitempty"`
	RepresentativeFieldID *ID     `json:"representativeFieldId,omitempty"`
}

type AddLayerGroupPayload struct {
	Layer       *LayerGroup `json:"layer"`
	ParentLayer *LayerGroup `json:"parentLayer"`
	Index       *int        `json:"index,omitempty"`
}

type AddLayerItemInput struct {
	ParentLayerID ID       `json:"parentLayerId"`
	PluginID      ID       `json:"pluginId"`
	ExtensionID   ID       `json:"extensionId"`
	Index         *int     `json:"index,omitempty"`
	Name          *string  `json:"name,omitempty"`
	Lat           *float64 `json:"lat,omitempty"`
	Lng           *float64 `json:"lng,omitempty"`
}

type AddLayerItemPayload struct {
	Layer       *LayerItem  `json:"layer"`
	ParentLayer *LayerGroup `json:"parentLayer"`
	Index       *int        `json:"index,omitempty"`
}

type AddMemberToTeamInput struct {
	TeamID ID   `json:"teamId"`
	UserID ID   `json:"userId"`
	Role   Role `json:"role"`
}

type AddMemberToTeamPayload struct {
	Team *Team `json:"team"`
}

type AddNLSInfoboxBlockInput struct {
	LayerID     ID   `json:"layerId"`
	PluginID    ID   `json:"pluginId"`
	ExtensionID ID   `json:"extensionId"`
	Index       *int `json:"index,omitempty"`
}

type AddNLSInfoboxBlockPayload struct {
	InfoboxBlock *InfoboxBlock `json:"infoboxBlock"`
	Layer        NLSLayer      `json:"layer"`
}

type AddNLSLayerSimpleInput struct {
	LayerType string `json:"layerType"`
	Title     string `json:"title"`
	SceneID   ID     `json:"sceneId"`
	Config    JSON   `json:"config,omitempty"`
	Index     *int   `json:"index,omitempty"`
	Visible   *bool  `json:"visible,omitempty"`
}

type AddNLSLayerSimplePayload struct {
	Layers *NLSLayerSimple `json:"layers"`
}

type AddPropertyItemInput struct {
	PropertyID     ID          `json:"propertyId"`
	SchemaGroupID  ID          `json:"schemaGroupId"`
	Index          *int        `json:"index,omitempty"`
	NameFieldValue interface{} `json:"nameFieldValue,omitempty"`
	NameFieldType  *ValueType  `json:"nameFieldType,omitempty"`
}

type AddStyleInput struct {
	SceneID ID     `json:"sceneId"`
	Name    string `json:"name"`
	Value   JSON   `json:"value"`
}

type AddStylePayload struct {
	Style *Style `json:"style"`
}

type AddWidgetInput struct {
	SceneID     ID `json:"sceneId"`
	PluginID    ID `json:"pluginId"`
	ExtensionID ID `json:"extensionId"`
}

type AddWidgetPayload struct {
	Scene       *Scene       `json:"scene"`
	SceneWidget *SceneWidget `json:"sceneWidget"`
}

type Asset struct {
	ID          ID        `json:"id"`
	CreatedAt   time.Time `json:"createdAt"`
	TeamID      ID        `json:"teamId"`
	Name        string    `json:"name"`
	Size        int64     `json:"size"`
	URL         string    `json:"url"`
	ContentType string    `json:"contentType"`
	Team        *Team     `json:"team,omitempty"`
}

func (Asset) IsNode()        {}
func (this Asset) GetID() ID { return this.ID }

type AssetConnection struct {
	Edges      []*AssetEdge `json:"edges"`
	Nodes      []*Asset     `json:"nodes"`
	PageInfo   *PageInfo    `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

type AssetEdge struct {
	Cursor usecasex.Cursor `json:"cursor"`
	Node   *Asset          `json:"node,omitempty"`
}

type AttachTagItemToGroupInput struct {
	ItemID  ID `json:"itemID"`
	GroupID ID `json:"groupID"`
}

type AttachTagItemToGroupPayload struct {
	Tag *TagGroup `json:"tag"`
}

type AttachTagToLayerInput struct {
	TagID   ID `json:"tagID"`
	LayerID ID `json:"layerID"`
}

type AttachTagToLayerPayload struct {
	Layer Layer `json:"layer"`
}

type Camera struct {
	Lat      float64 `json:"lat"`
	Lng      float64 `json:"lng"`
	Altitude float64 `json:"altitude"`
	Heading  float64 `json:"heading"`
	Pitch    float64 `json:"pitch"`
	Roll     float64 `json:"roll"`
	Fov      float64 `json:"fov"`
}

type Cluster struct {
	ID         ID        `json:"id"`
	Name       string    `json:"name"`
	PropertyID ID        `json:"propertyId"`
	Property   *Property `json:"property,omitempty"`
}

type CreateAssetInput struct {
	TeamID ID             `json:"teamId"`
	File   graphql.Upload `json:"file"`
}

type CreateAssetPayload struct {
	Asset *Asset `json:"asset"`
}

type CreateInfoboxInput struct {
	LayerID ID `json:"layerId"`
}

type CreateInfoboxPayload struct {
	Layer Layer `json:"layer"`
}

type CreateNLSInfoboxInput struct {
	LayerID ID `json:"layerId"`
}

type CreateNLSInfoboxPayload struct {
	Layer NLSLayer `json:"layer"`
}

type CreateProjectInput struct {
	TeamID      ID         `json:"teamId"`
	Visualizer  Visualizer `json:"visualizer"`
	Name        *string    `json:"name,omitempty"`
	Description *string    `json:"description,omitempty"`
	ImageURL    *url.URL   `json:"imageUrl,omitempty"`
	Alias       *string    `json:"alias,omitempty"`
	Archived    *bool      `json:"archived,omitempty"`
	CoreSupport *bool      `json:"coreSupport,omitempty"`
}

type CreateSceneInput struct {
	ProjectID ID `json:"projectId"`
}

type CreateScenePayload struct {
	Scene *Scene `json:"scene"`
}

type CreateStoryBlockInput struct {
	StoryID     ID   `json:"storyId"`
	PageID      ID   `json:"pageId"`
	PluginID    ID   `json:"pluginId"`
	ExtensionID ID   `json:"extensionId"`
	Index       *int `json:"index,omitempty"`
}

type CreateStoryBlockPayload struct {
	Block *StoryBlock `json:"block"`
	Page  *StoryPage  `json:"page"`
	Story *Story      `json:"story"`
	Index int         `json:"index"`
}

type CreateStoryInput struct {
	SceneID ID     `json:"sceneId"`
	Title   string `json:"title"`
	Index   *int   `json:"index,omitempty"`
}

type CreateStoryPageInput struct {
	SceneID         ID      `json:"sceneId"`
	StoryID         ID      `json:"storyId"`
	Title           *string `json:"title,omitempty"`
	Swipeable       *bool   `json:"swipeable,omitempty"`
	Layers          []ID    `json:"layers,omitempty"`
	SwipeableLayers []ID    `json:"swipeableLayers,omitempty"`
	Index           *int    `json:"index,omitempty"`
}

type CreateTagGroupInput struct {
	SceneID ID     `json:"sceneId"`
	Label   string `json:"label"`
	Tags    []ID   `json:"tags,omitempty"`
}

type CreateTagGroupPayload struct {
	Tag *TagGroup `json:"tag"`
}

type CreateTagItemInput struct {
	SceneID               ID     `json:"sceneId"`
	Label                 string `json:"label"`
	Parent                *ID    `json:"parent,omitempty"`
	LinkedDatasetSchemaID *ID    `json:"linkedDatasetSchemaID,omitempty"`
	LinkedDatasetID       *ID    `json:"linkedDatasetID,omitempty"`
	LinkedDatasetField    *ID    `json:"linkedDatasetField,omitempty"`
}

type CreateTagItemPayload struct {
	Tag    *TagItem  `json:"tag"`
	Parent *TagGroup `json:"parent,omitempty"`
}

type CreateTeamInput struct {
	Name string `json:"name"`
}

type CreateTeamPayload struct {
	Team *Team `json:"team"`
}

type Dataset struct {
	ID       ID              `json:"id"`
	Source   string          `json:"source"`
	SchemaID ID              `json:"schemaId"`
	Fields   []*DatasetField `json:"fields"`
	Schema   *DatasetSchema  `json:"schema,omitempty"`
	Name     *string         `json:"name,omitempty"`
}

func (Dataset) IsNode()        {}
func (this Dataset) GetID() ID { return this.ID }

type DatasetConnection struct {
	Edges      []*DatasetEdge `json:"edges"`
	Nodes      []*Dataset     `json:"nodes"`
	PageInfo   *PageInfo      `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

type DatasetEdge struct {
	Cursor usecasex.Cursor `json:"cursor"`
	Node   *Dataset        `json:"node,omitempty"`
}

type DatasetField struct {
	FieldID  ID                  `json:"fieldId"`
	SchemaID ID                  `json:"schemaId"`
	Source   string              `json:"source"`
	Type     ValueType           `json:"type"`
	Value    interface{}         `json:"value,omitempty"`
	Schema   *DatasetSchema      `json:"schema,omitempty"`
	Field    *DatasetSchemaField `json:"field,omitempty"`
	ValueRef *Dataset            `json:"valueRef,omitempty"`
}

type DatasetSchema struct {
	ID                    ID                    `json:"id"`
	Source                string                `json:"source"`
	Name                  string                `json:"name"`
	SceneID               ID                    `json:"sceneId"`
	Fields                []*DatasetSchemaField `json:"fields"`
	TotalCount            int                   `json:"totalCount"`
	RepresentativeFieldID *ID                   `json:"representativeFieldId,omitempty"`
	Dynamic               *bool                 `json:"dynamic,omitempty"`
	Datasets              *DatasetConnection    `json:"datasets"`
	Scene                 *Scene                `json:"scene,omitempty"`
	RepresentativeField   *DatasetSchemaField   `json:"representativeField,omitempty"`
}

func (DatasetSchema) IsNode()        {}
func (this DatasetSchema) GetID() ID { return this.ID }

type DatasetSchemaConnection struct {
	Edges      []*DatasetSchemaEdge `json:"edges"`
	Nodes      []*DatasetSchema     `json:"nodes"`
	PageInfo   *PageInfo            `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

type DatasetSchemaEdge struct {
	Cursor usecasex.Cursor `json:"cursor"`
	Node   *DatasetSchema  `json:"node,omitempty"`
}

type DatasetSchemaField struct {
	ID       ID             `json:"id"`
	Source   string         `json:"source"`
	Name     string         `json:"name"`
	Type     ValueType      `json:"type"`
	SchemaID ID             `json:"schemaId"`
	RefID    *ID            `json:"refId,omitempty"`
	Schema   *DatasetSchema `json:"schema,omitempty"`
	Ref      *DatasetSchema `json:"ref,omitempty"`
}

func (DatasetSchemaField) IsNode()        {}
func (this DatasetSchemaField) GetID() ID { return this.ID }

type DeleteMeInput struct {
	UserID ID `json:"userId"`
}

type DeleteMePayload struct {
	UserID ID `json:"userId"`
}

type DeleteProjectInput struct {
	ProjectID ID `json:"projectId"`
}

type DeleteProjectPayload struct {
	ProjectID ID `json:"projectId"`
}

type DeleteStoryInput struct {
	SceneID ID `json:"sceneId"`
	StoryID ID `json:"storyId"`
}

type DeleteStoryPageInput struct {
	SceneID ID `json:"sceneId"`
	StoryID ID `json:"storyId"`
	PageID  ID `json:"pageId"`
}

type DeleteStoryPagePayload struct {
	PageID ID     `json:"pageId"`
	Story  *Story `json:"story"`
}

type DeleteStoryPayload struct {
	StoryID ID `json:"storyId"`
}

type DeleteTeamInput struct {
	TeamID ID `json:"teamId"`
}

type DeleteTeamPayload struct {
	TeamID ID `json:"teamId"`
}

type DetachTagFromLayerInput struct {
	TagID   ID `json:"tagID"`
	LayerID ID `json:"layerID"`
}

type DetachTagFromLayerPayload struct {
	Layer Layer `json:"layer"`
}

type DetachTagItemFromGroupInput struct {
	ItemID  ID `json:"itemID"`
	GroupID ID `json:"groupID"`
}

type DetachTagItemFromGroupPayload struct {
	Tag *TagGroup `json:"tag"`
}

type DuplicateNLSLayerInput struct {
	LayerID ID `json:"layerId"`
}

type DuplicateNLSLayerPayload struct {
	Layer NLSLayer `json:"layer"`
}

type DuplicateStoryPageInput struct {
	SceneID ID `json:"sceneId"`
	StoryID ID `json:"storyId"`
	PageID  ID `json:"pageId"`
}

type DuplicateStyleInput struct {
	StyleID ID `json:"styleId"`
}

type DuplicateStylePayload struct {
	Style *Style `json:"style"`
}

type ImportDatasetFromGoogleSheetInput struct {
	AccessToken     string `json:"accessToken"`
	FileID          string `json:"fileId"`
	SheetName       string `json:"sheetName"`
	SceneID         ID     `json:"sceneId"`
	DatasetSchemaID *ID    `json:"datasetSchemaId,omitempty"`
}

type ImportDatasetInput struct {
	File            graphql.Upload `json:"file"`
	SceneID         ID             `json:"sceneId"`
	DatasetSchemaID *ID            `json:"datasetSchemaId,omitempty"`
}

type ImportDatasetPayload struct {
	DatasetSchema *DatasetSchema `json:"datasetSchema"`
}

type ImportLayerInput struct {
	LayerID ID                  `json:"layerId"`
	File    graphql.Upload      `json:"file"`
	Format  LayerEncodingFormat `json:"format"`
}

type ImportLayerPayload struct {
	Layers      []Layer     `json:"layers"`
	ParentLayer *LayerGroup `json:"parentLayer"`
}

type Infobox struct {
	SceneID         ID              `json:"sceneId"`
	LayerID         ID              `json:"layerId"`
	PropertyID      ID              `json:"propertyId"`
	Fields          []*InfoboxField `json:"fields"`
	LinkedDatasetID *ID             `json:"linkedDatasetId,omitempty"`
	Layer           Layer           `json:"layer"`
	Property        *Property       `json:"property,omitempty"`
	LinkedDataset   *Dataset        `json:"linkedDataset,omitempty"`
	Merged          *MergedInfobox  `json:"merged,omitempty"`
	Scene           *Scene          `json:"scene,omitempty"`
}

type InfoboxBlock struct {
	ID          ID               `json:"id"`
	SceneID     ID               `json:"sceneId"`
	LayerID     ID               `json:"layerId"`
	PropertyID  ID               `json:"propertyId"`
	Property    *Property        `json:"property,omitempty"`
	PluginID    ID               `json:"pluginId"`
	Plugin      *Plugin          `json:"plugin,omitempty"`
	ExtensionID ID               `json:"extensionId"`
	Extension   *PluginExtension `json:"extension,omitempty"`
	Scene       *Scene           `json:"scene,omitempty"`
}

type InfoboxField struct {
	ID              ID                  `json:"id"`
	SceneID         ID                  `json:"sceneId"`
	LayerID         ID                  `json:"layerId"`
	PropertyID      ID                  `json:"propertyId"`
	PluginID        ID                  `json:"pluginId"`
	ExtensionID     ID                  `json:"extensionId"`
	LinkedDatasetID *ID                 `json:"linkedDatasetId,omitempty"`
	Layer           Layer               `json:"layer"`
	Infobox         *Infobox            `json:"infobox"`
	Property        *Property           `json:"property,omitempty"`
	Plugin          *Plugin             `json:"plugin,omitempty"`
	Extension       *PluginExtension    `json:"extension,omitempty"`
	LinkedDataset   *Dataset            `json:"linkedDataset,omitempty"`
	Merged          *MergedInfoboxField `json:"merged,omitempty"`
	Scene           *Scene              `json:"scene,omitempty"`
	ScenePlugin     *ScenePlugin        `json:"scenePlugin,omitempty"`
}

type InstallPluginInput struct {
	SceneID  ID `json:"sceneId"`
	PluginID ID `json:"pluginId"`
}

type InstallPluginPayload struct {
	Scene       *Scene       `json:"scene"`
	ScenePlugin *ScenePlugin `json:"scenePlugin"`
}

type LatLng struct {
	Lat float64 `json:"lat"`
	Lng float64 `json:"lng"`
}

type LatLngHeight struct {
	Lat    float64 `json:"lat"`
	Lng    float64 `json:"lng"`
	Height float64 `json:"height"`
}

type LayerGroup struct {
	ID                    ID               `json:"id"`
	SceneID               ID               `json:"sceneId"`
	Name                  string           `json:"name"`
	IsVisible             bool             `json:"isVisible"`
	PropertyID            *ID              `json:"propertyId,omitempty"`
	PluginID              *ID              `json:"pluginId,omitempty"`
	ExtensionID           *ID              `json:"extensionId,omitempty"`
	Infobox               *Infobox         `json:"infobox,omitempty"`
	ParentID              *ID              `json:"parentId,omitempty"`
	LinkedDatasetSchemaID *ID              `json:"linkedDatasetSchemaId,omitempty"`
	Root                  bool             `json:"root"`
	LayerIds              []ID             `json:"layerIds"`
	Tags                  []LayerTag       `json:"tags"`
	Parent                *LayerGroup      `json:"parent,omitempty"`
	Property              *Property        `json:"property,omitempty"`
	Plugin                *Plugin          `json:"plugin,omitempty"`
	Extension             *PluginExtension `json:"extension,omitempty"`
	LinkedDatasetSchema   *DatasetSchema   `json:"linkedDatasetSchema,omitempty"`
	Layers                []Layer          `json:"layers"`
	Scene                 *Scene           `json:"scene,omitempty"`
	ScenePlugin           *ScenePlugin     `json:"scenePlugin,omitempty"`
}

func (LayerGroup) IsLayer()                            {}
func (this LayerGroup) GetID() ID                      { return this.ID }
func (this LayerGroup) GetSceneID() ID                 { return this.SceneID }
func (this LayerGroup) GetName() string                { return this.Name }
func (this LayerGroup) GetIsVisible() bool             { return this.IsVisible }
func (this LayerGroup) GetPropertyID() *ID             { return this.PropertyID }
func (this LayerGroup) GetPluginID() *ID               { return this.PluginID }
func (this LayerGroup) GetExtensionID() *ID            { return this.ExtensionID }
func (this LayerGroup) GetInfobox() *Infobox           { return this.Infobox }
func (this LayerGroup) GetParentID() *ID               { return this.ParentID }
func (this LayerGroup) GetParent() *LayerGroup         { return this.Parent }
func (this LayerGroup) GetProperty() *Property         { return this.Property }
func (this LayerGroup) GetPlugin() *Plugin             { return this.Plugin }
func (this LayerGroup) GetExtension() *PluginExtension { return this.Extension }
func (this LayerGroup) GetScenePlugin() *ScenePlugin   { return this.ScenePlugin }
func (this LayerGroup) GetTags() []LayerTag {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]LayerTag, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type LayerItem struct {
	ID              ID               `json:"id"`
	SceneID         ID               `json:"sceneId"`
	Name            string           `json:"name"`
	IsVisible       bool             `json:"isVisible"`
	PropertyID      *ID              `json:"propertyId,omitempty"`
	PluginID        *ID              `json:"pluginId,omitempty"`
	ExtensionID     *ID              `json:"extensionId,omitempty"`
	Infobox         *Infobox         `json:"infobox,omitempty"`
	ParentID        *ID              `json:"parentId,omitempty"`
	LinkedDatasetID *ID              `json:"linkedDatasetId,omitempty"`
	Tags            []LayerTag       `json:"tags"`
	Parent          *LayerGroup      `json:"parent,omitempty"`
	Property        *Property        `json:"property,omitempty"`
	Plugin          *Plugin          `json:"plugin,omitempty"`
	Extension       *PluginExtension `json:"extension,omitempty"`
	LinkedDataset   *Dataset         `json:"linkedDataset,omitempty"`
	Merged          *MergedLayer     `json:"merged,omitempty"`
	Scene           *Scene           `json:"scene,omitempty"`
	ScenePlugin     *ScenePlugin     `json:"scenePlugin,omitempty"`
}

func (LayerItem) IsLayer()                            {}
func (this LayerItem) GetID() ID                      { return this.ID }
func (this LayerItem) GetSceneID() ID                 { return this.SceneID }
func (this LayerItem) GetName() string                { return this.Name }
func (this LayerItem) GetIsVisible() bool             { return this.IsVisible }
func (this LayerItem) GetPropertyID() *ID             { return this.PropertyID }
func (this LayerItem) GetPluginID() *ID               { return this.PluginID }
func (this LayerItem) GetExtensionID() *ID            { return this.ExtensionID }
func (this LayerItem) GetInfobox() *Infobox           { return this.Infobox }
func (this LayerItem) GetParentID() *ID               { return this.ParentID }
func (this LayerItem) GetParent() *LayerGroup         { return this.Parent }
func (this LayerItem) GetProperty() *Property         { return this.Property }
func (this LayerItem) GetPlugin() *Plugin             { return this.Plugin }
func (this LayerItem) GetExtension() *PluginExtension { return this.Extension }
func (this LayerItem) GetScenePlugin() *ScenePlugin   { return this.ScenePlugin }
func (this LayerItem) GetTags() []LayerTag {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]LayerTag, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type LayerTagGroup struct {
	TagID    ID              `json:"tagId"`
	Children []*LayerTagItem `json:"children"`
	Tag      Tag             `json:"tag,omitempty"`
}

func (LayerTagGroup) IsLayerTag()       {}
func (this LayerTagGroup) GetTagID() ID { return this.TagID }
func (this LayerTagGroup) GetTag() Tag  { return this.Tag }

type LayerTagItem struct {
	TagID ID  `json:"tagId"`
	Tag   Tag `json:"tag,omitempty"`
}

func (LayerTagItem) IsLayerTag()       {}
func (this LayerTagItem) GetTagID() ID { return this.TagID }
func (this LayerTagItem) GetTag() Tag  { return this.Tag }

type LinkDatasetToPropertyValueInput struct {
	PropertyID            ID   `json:"propertyId"`
	SchemaGroupID         *ID  `json:"schemaGroupId,omitempty"`
	ItemID                *ID  `json:"itemId,omitempty"`
	FieldID               ID   `json:"fieldId"`
	DatasetSchemaIds      []ID `json:"datasetSchemaIds"`
	DatasetSchemaFieldIds []ID `json:"datasetSchemaFieldIds"`
	DatasetIds            []ID `json:"datasetIds,omitempty"`
}

type Me struct {
	ID       ID           `json:"id"`
	Name     string       `json:"name"`
	Email    string       `json:"email"`
	Lang     language.Tag `json:"lang"`
	Theme    Theme        `json:"theme"`
	MyTeamID ID           `json:"myTeamId"`
	Auths    []string     `json:"auths"`
	Teams    []*Team      `json:"teams"`
	MyTeam   *Team        `json:"myTeam,omitempty"`
}

type MergedInfobox struct {
	SceneID  ID                    `json:"sceneID"`
	Property *MergedProperty       `json:"property,omitempty"`
	Fields   []*MergedInfoboxField `json:"fields"`
	Scene    *Scene                `json:"scene,omitempty"`
}

type MergedInfoboxField struct {
	OriginalID  ID               `json:"originalId"`
	SceneID     ID               `json:"sceneID"`
	PluginID    ID               `json:"pluginId"`
	ExtensionID ID               `json:"extensionId"`
	Property    *MergedProperty  `json:"property,omitempty"`
	Plugin      *Plugin          `json:"plugin,omitempty"`
	Extension   *PluginExtension `json:"extension,omitempty"`
	Scene       *Scene           `json:"scene,omitempty"`
	ScenePlugin *ScenePlugin     `json:"scenePlugin,omitempty"`
}

type MergedLayer struct {
	OriginalID ID              `json:"originalId"`
	ParentID   *ID             `json:"parentId,omitempty"`
	SceneID    ID              `json:"sceneID"`
	Property   *MergedProperty `json:"property,omitempty"`
	Infobox    *MergedInfobox  `json:"infobox,omitempty"`
	Original   *LayerItem      `json:"original,omitempty"`
	Parent     *LayerGroup     `json:"parent,omitempty"`
	Scene      *Scene          `json:"scene,omitempty"`
}

type MergedProperty struct {
	OriginalID      *ID                    `json:"originalId,omitempty"`
	ParentID        *ID                    `json:"parentId,omitempty"`
	SchemaID        *ID                    `json:"schemaId,omitempty"`
	LinkedDatasetID *ID                    `json:"linkedDatasetId,omitempty"`
	Original        *Property              `json:"original,omitempty"`
	Parent          *Property              `json:"parent,omitempty"`
	Schema          *PropertySchema        `json:"schema,omitempty"`
	LinkedDataset   *Dataset               `json:"linkedDataset,omitempty"`
	Groups          []*MergedPropertyGroup `json:"groups"`
}

type MergedPropertyField struct {
	SchemaID    ID                   `json:"schemaId"`
	FieldID     ID                   `json:"fieldId"`
	Value       interface{}          `json:"value,omitempty"`
	Type        ValueType            `json:"type"`
	Links       []*PropertyFieldLink `json:"links,omitempty"`
	Overridden  bool                 `json:"overridden"`
	Schema      *PropertySchema      `json:"schema,omitempty"`
	Field       *PropertySchemaField `json:"field,omitempty"`
	ActualValue interface{}          `json:"actualValue,omitempty"`
}

type MergedPropertyGroup struct {
	OriginalPropertyID *ID                    `json:"originalPropertyId,omitempty"`
	ParentPropertyID   *ID                    `json:"parentPropertyId,omitempty"`
	OriginalID         *ID                    `json:"originalId,omitempty"`
	ParentID           *ID                    `json:"parentId,omitempty"`
	SchemaGroupID      ID                     `json:"schemaGroupId"`
	SchemaID           *ID                    `json:"schemaId,omitempty"`
	LinkedDatasetID    *ID                    `json:"linkedDatasetId,omitempty"`
	Fields             []*MergedPropertyField `json:"fields"`
	Groups             []*MergedPropertyGroup `json:"groups"`
	OriginalProperty   *Property              `json:"originalProperty,omitempty"`
	ParentProperty     *Property              `json:"parentProperty,omitempty"`
	Original           *PropertyGroup         `json:"original,omitempty"`
	Parent             *PropertyGroup         `json:"parent,omitempty"`
	Schema             *PropertySchema        `json:"schema,omitempty"`
	LinkedDataset      *Dataset               `json:"linkedDataset,omitempty"`
}

type MoveInfoboxFieldInput struct {
	LayerID        ID  `json:"layerId"`
	InfoboxFieldID ID  `json:"infoboxFieldId"`
	Index          int `json:"index"`
}

type MoveInfoboxFieldPayload struct {
	InfoboxFieldID ID    `json:"infoboxFieldId"`
	Layer          Layer `json:"layer"`
	Index          int   `json:"index"`
}

type MoveLayerInput struct {
	LayerID     ID   `json:"layerId"`
	DestLayerID *ID  `json:"destLayerId,omitempty"`
	Index       *int `json:"index,omitempty"`
}

type MoveLayerPayload struct {
	LayerID         ID          `json:"layerId"`
	FromParentLayer *LayerGroup `json:"fromParentLayer"`
	ToParentLayer   *LayerGroup `json:"toParentLayer"`
	Index           int         `json:"index"`
}

type MoveNLSInfoboxBlockInput struct {
	LayerID        ID  `json:"layerId"`
	InfoboxBlockID ID  `json:"infoboxBlockId"`
	Index          int `json:"index"`
}

type MoveNLSInfoboxBlockPayload struct {
	InfoboxBlockID ID       `json:"infoboxBlockId"`
	Layer          NLSLayer `json:"layer"`
	Index          int      `json:"index"`
}

type MovePropertyItemInput struct {
	PropertyID    ID  `json:"propertyId"`
	SchemaGroupID ID  `json:"schemaGroupId"`
	ItemID        ID  `json:"itemId"`
	Index         int `json:"index"`
}

type MoveStoryBlockInput struct {
	StoryID ID  `json:"storyId"`
	PageID  ID  `json:"pageId"`
	BlockID ID  `json:"blockId"`
	Index   int `json:"index"`
}

type MoveStoryBlockPayload struct {
	Page    *StoryPage `json:"page"`
	Story   *Story     `json:"story"`
	BlockID ID         `json:"blockId"`
	Index   int        `json:"index"`
}

type MoveStoryInput struct {
	SceneID ID  `json:"sceneId"`
	StoryID ID  `json:"storyId"`
	Index   int `json:"index"`
}

type MoveStoryPageInput struct {
	StoryID ID  `json:"storyId"`
	PageID  ID  `json:"pageId"`
	Index   int `json:"index"`
}

type MoveStoryPagePayload struct {
	Page  *StoryPage `json:"page"`
	Story *Story     `json:"story"`
	Index int        `json:"index"`
}

type MoveStoryPayload struct {
	StoryID ID       `json:"storyId"`
	Index   int      `json:"index"`
	Stories []*Story `json:"stories"`
}

type Mutation struct {
}

type NLSInfobox struct {
	ID         ID              `json:"id"`
	SceneID    ID              `json:"sceneId"`
	LayerID    ID              `json:"layerId"`
	PropertyID ID              `json:"propertyId"`
	Blocks     []*InfoboxBlock `json:"blocks"`
	Property   *Property       `json:"property,omitempty"`
	Scene      *Scene          `json:"scene,omitempty"`
}

type NLSLayerGroup struct {
	ID          ID          `json:"id"`
	LayerType   string      `json:"layerType"`
	SceneID     ID          `json:"sceneId"`
	Children    []NLSLayer  `json:"children"`
	ChildrenIds []ID        `json:"childrenIds"`
	Config      JSON        `json:"config,omitempty"`
	Title       string      `json:"title"`
	Visible     bool        `json:"visible"`
	Infobox     *NLSInfobox `json:"infobox,omitempty"`
	Scene       *Scene      `json:"scene,omitempty"`
}

func (NLSLayerGroup) IsNLSLayer()                  {}
func (this NLSLayerGroup) GetID() ID               { return this.ID }
func (this NLSLayerGroup) GetLayerType() string    { return this.LayerType }
func (this NLSLayerGroup) GetSceneID() ID          { return this.SceneID }
func (this NLSLayerGroup) GetConfig() JSON         { return this.Config }
func (this NLSLayerGroup) GetTitle() string        { return this.Title }
func (this NLSLayerGroup) GetVisible() bool        { return this.Visible }
func (this NLSLayerGroup) GetInfobox() *NLSInfobox { return this.Infobox }

type NLSLayerSimple struct {
	ID        ID          `json:"id"`
	LayerType string      `json:"layerType"`
	SceneID   ID          `json:"sceneId"`
	Config    JSON        `json:"config,omitempty"`
	Title     string      `json:"title"`
	Visible   bool        `json:"visible"`
	Infobox   *NLSInfobox `json:"infobox,omitempty"`
	Scene     *Scene      `json:"scene,omitempty"`
}

func (NLSLayerSimple) IsNLSLayer()                  {}
func (this NLSLayerSimple) GetID() ID               { return this.ID }
func (this NLSLayerSimple) GetLayerType() string    { return this.LayerType }
func (this NLSLayerSimple) GetSceneID() ID          { return this.SceneID }
func (this NLSLayerSimple) GetConfig() JSON         { return this.Config }
func (this NLSLayerSimple) GetTitle() string        { return this.Title }
func (this NLSLayerSimple) GetVisible() bool        { return this.Visible }
func (this NLSLayerSimple) GetInfobox() *NLSInfobox { return this.Infobox }

type PageInfo struct {
	StartCursor     *usecasex.Cursor `json:"startCursor,omitempty"`
	EndCursor       *usecasex.Cursor `json:"endCursor,omitempty"`
	HasNextPage     bool             `json:"hasNextPage"`
	HasPreviousPage bool             `json:"hasPreviousPage"`
}

type PageLayerInput struct {
	SceneID   ID    `json:"sceneId"`
	StoryID   ID    `json:"storyId"`
	PageID    ID    `json:"pageId"`
	Swipeable *bool `json:"swipeable,omitempty"`
	LayerID   ID    `json:"layerId"`
}

type Pagination struct {
	First  *int             `json:"first,omitempty"`
	Last   *int             `json:"last,omitempty"`
	After  *usecasex.Cursor `json:"after,omitempty"`
	Before *usecasex.Cursor `json:"before,omitempty"`
}

type Plugin struct {
	ID                       ID                 `json:"id"`
	SceneID                  *ID                `json:"sceneId,omitempty"`
	Name                     string             `json:"name"`
	Version                  string             `json:"version"`
	Description              string             `json:"description"`
	Author                   string             `json:"author"`
	RepositoryURL            string             `json:"repositoryUrl"`
	PropertySchemaID         *ID                `json:"propertySchemaId,omitempty"`
	Extensions               []*PluginExtension `json:"extensions"`
	ScenePlugin              *ScenePlugin       `json:"scenePlugin,omitempty"`
	AllTranslatedDescription map[string]string  `json:"allTranslatedDescription,omitempty"`
	AllTranslatedName        map[string]string  `json:"allTranslatedName,omitempty"`
	Scene                    *Scene             `json:"scene,omitempty"`
	TranslatedName           string             `json:"translatedName"`
	TranslatedDescription    string             `json:"translatedDescription"`
	PropertySchema           *PropertySchema    `json:"propertySchema,omitempty"`
}

type PluginExtension struct {
	ExtensionID              ID                  `json:"extensionId"`
	PluginID                 ID                  `json:"pluginId"`
	Type                     PluginExtensionType `json:"type"`
	Name                     string              `json:"name"`
	Description              string              `json:"description"`
	Icon                     string              `json:"icon"`
	SingleOnly               *bool               `json:"singleOnly,omitempty"`
	WidgetLayout             *WidgetLayout       `json:"widgetLayout,omitempty"`
	Visualizer               *Visualizer         `json:"visualizer,omitempty"`
	PropertySchemaID         ID                  `json:"propertySchemaId"`
	AllTranslatedName        map[string]string   `json:"allTranslatedName,omitempty"`
	AllTranslatedDescription map[string]string   `json:"allTranslatedDescription,omitempty"`
	Plugin                   *Plugin             `json:"plugin,omitempty"`
	SceneWidget              *SceneWidget        `json:"sceneWidget,omitempty"`
	PropertySchema           *PropertySchema     `json:"propertySchema,omitempty"`
	TranslatedName           string              `json:"translatedName"`
	TranslatedDescription    string              `json:"translatedDescription"`
}

type Policy struct {
	ID                    ID     `json:"id"`
	Name                  string `json:"name"`
	ProjectCount          *int   `json:"projectCount,omitempty"`
	MemberCount           *int   `json:"memberCount,omitempty"`
	PublishedProjectCount *int   `json:"publishedProjectCount,omitempty"`
	LayerCount            *int   `json:"layerCount,omitempty"`
	AssetStorageSize      *int64 `json:"assetStorageSize,omitempty"`
	DatasetSchemaCount    *int   `json:"datasetSchemaCount,omitempty"`
	DatasetCount          *int   `json:"datasetCount,omitempty"`
}

type Project struct {
	ID                ID                `json:"id"`
	IsArchived        bool              `json:"isArchived"`
	IsBasicAuthActive bool              `json:"isBasicAuthActive"`
	BasicAuthUsername string            `json:"basicAuthUsername"`
	BasicAuthPassword string            `json:"basicAuthPassword"`
	CreatedAt         time.Time         `json:"createdAt"`
	UpdatedAt         time.Time         `json:"updatedAt"`
	PublishedAt       *time.Time        `json:"publishedAt,omitempty"`
	Name              string            `json:"name"`
	Description       string            `json:"description"`
	Alias             string            `json:"alias"`
	PublicTitle       string            `json:"publicTitle"`
	PublicDescription string            `json:"publicDescription"`
	PublicImage       string            `json:"publicImage"`
	PublicNoIndex     bool              `json:"publicNoIndex"`
	ImageURL          *url.URL          `json:"imageUrl,omitempty"`
	TeamID            ID                `json:"teamId"`
	Visualizer        Visualizer        `json:"visualizer"`
	PublishmentStatus PublishmentStatus `json:"publishmentStatus"`
	Team              *Team             `json:"team,omitempty"`
	Scene             *Scene            `json:"scene,omitempty"`
	CoreSupport       bool              `json:"coreSupport"`
	EnableGa          bool              `json:"enableGa"`
	TrackingID        string            `json:"trackingId"`
}

func (Project) IsNode()        {}
func (this Project) GetID() ID { return this.ID }

type ProjectAliasAvailability struct {
	Alias     string `json:"alias"`
	Available bool   `json:"available"`
}

type ProjectConnection struct {
	Edges      []*ProjectEdge `json:"edges"`
	Nodes      []*Project     `json:"nodes"`
	PageInfo   *PageInfo      `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

type ProjectEdge struct {
	Cursor usecasex.Cursor `json:"cursor"`
	Node   *Project        `json:"node,omitempty"`
}

type ProjectPayload struct {
	Project *Project `json:"project"`
}

type Property struct {
	ID       ID              `json:"id"`
	SchemaID ID              `json:"schemaId"`
	Items    []PropertyItem  `json:"items"`
	Schema   *PropertySchema `json:"schema,omitempty"`
	Layer    Layer           `json:"layer,omitempty"`
	Merged   *MergedProperty `json:"merged,omitempty"`
}

func (Property) IsNode()        {}
func (this Property) GetID() ID { return this.ID }

type PropertyCondition struct {
	FieldID ID          `json:"fieldId"`
	Type    ValueType   `json:"type"`
	Value   interface{} `json:"value,omitempty"`
}

type PropertyField struct {
	ID          string               `json:"id"`
	ParentID    ID                   `json:"parentId"`
	SchemaID    ID                   `json:"schemaId"`
	FieldID     ID                   `json:"fieldId"`
	Links       []*PropertyFieldLink `json:"links,omitempty"`
	Type        ValueType            `json:"type"`
	Value       interface{}          `json:"value,omitempty"`
	Parent      *Property            `json:"parent,omitempty"`
	Schema      *PropertySchema      `json:"schema,omitempty"`
	Field       *PropertySchemaField `json:"field,omitempty"`
	ActualValue interface{}          `json:"actualValue,omitempty"`
}

type PropertyFieldLink struct {
	DatasetID            *ID                 `json:"datasetId,omitempty"`
	DatasetSchemaID      ID                  `json:"datasetSchemaId"`
	DatasetSchemaFieldID ID                  `json:"datasetSchemaFieldId"`
	Dataset              *Dataset            `json:"dataset,omitempty"`
	DatasetField         *DatasetField       `json:"datasetField,omitempty"`
	DatasetSchema        *DatasetSchema      `json:"datasetSchema,omitempty"`
	DatasetSchemaField   *DatasetSchemaField `json:"datasetSchemaField,omitempty"`
}

type PropertyFieldPayload struct {
	Property      *Property      `json:"property"`
	PropertyField *PropertyField `json:"propertyField,omitempty"`
}

type PropertyGroup struct {
	ID            ID                   `json:"id"`
	SchemaID      ID                   `json:"schemaId"`
	SchemaGroupID ID                   `json:"schemaGroupId"`
	Fields        []*PropertyField     `json:"fields"`
	Schema        *PropertySchema      `json:"schema,omitempty"`
	SchemaGroup   *PropertySchemaGroup `json:"schemaGroup,omitempty"`
}

func (PropertyGroup) IsPropertyItem() {}

type PropertyGroupList struct {
	ID            ID                   `json:"id"`
	SchemaID      ID                   `json:"schemaId"`
	SchemaGroupID ID                   `json:"schemaGroupId"`
	Groups        []*PropertyGroup     `json:"groups"`
	Schema        *PropertySchema      `json:"schema,omitempty"`
	SchemaGroup   *PropertySchemaGroup `json:"schemaGroup,omitempty"`
}

func (PropertyGroupList) IsPropertyItem() {}

type PropertyItemPayload struct {
	Property     *Property    `json:"property"`
	PropertyItem PropertyItem `json:"propertyItem,omitempty"`
}

type PropertyLinkableFields struct {
	SchemaID    ID                   `json:"schemaId"`
	Latlng      *ID                  `json:"latlng,omitempty"`
	URL         *ID                  `json:"url,omitempty"`
	LatlngField *PropertySchemaField `json:"latlngField,omitempty"`
	URLField    *PropertySchemaField `json:"urlField,omitempty"`
	Schema      *PropertySchema      `json:"schema,omitempty"`
}

type PropertySchema struct {
	ID             ID                      `json:"id"`
	Groups         []*PropertySchemaGroup  `json:"groups"`
	LinkableFields *PropertyLinkableFields `json:"linkableFields"`
}

type PropertySchemaField struct {
	FieldID                  ID                           `json:"fieldId"`
	Type                     ValueType                    `json:"type"`
	Title                    string                       `json:"title"`
	Description              string                       `json:"description"`
	Prefix                   *string                      `json:"prefix,omitempty"`
	Suffix                   *string                      `json:"suffix,omitempty"`
	DefaultValue             interface{}                  `json:"defaultValue,omitempty"`
	UI                       *PropertySchemaFieldUI       `json:"ui,omitempty"`
	Min                      *float64                     `json:"min,omitempty"`
	Max                      *float64                     `json:"max,omitempty"`
	Choices                  []*PropertySchemaFieldChoice `json:"choices,omitempty"`
	IsAvailableIf            *PropertyCondition           `json:"isAvailableIf,omitempty"`
	AllTranslatedTitle       map[string]string            `json:"allTranslatedTitle,omitempty"`
	AllTranslatedDescription map[string]string            `json:"allTranslatedDescription,omitempty"`
	TranslatedTitle          string                       `json:"translatedTitle"`
	TranslatedDescription    string                       `json:"translatedDescription"`
}

type PropertySchemaFieldChoice struct {
	Key                string            `json:"key"`
	Title              string            `json:"title"`
	Icon               *string           `json:"icon,omitempty"`
	AllTranslatedTitle map[string]string `json:"allTranslatedTitle,omitempty"`
	TranslatedTitle    string            `json:"translatedTitle"`
}

type PropertySchemaGroup struct {
	SchemaGroupID         ID                     `json:"schemaGroupId"`
	SchemaID              ID                     `json:"schemaId"`
	Fields                []*PropertySchemaField `json:"fields"`
	Collection            *string                `json:"collection,omitempty"`
	IsList                bool                   `json:"isList"`
	IsAvailableIf         *PropertyCondition     `json:"isAvailableIf,omitempty"`
	Title                 *string                `json:"title,omitempty"`
	AllTranslatedTitle    map[string]string      `json:"allTranslatedTitle,omitempty"`
	RepresentativeFieldID *ID                    `json:"representativeFieldId,omitempty"`
	RepresentativeField   *PropertySchemaField   `json:"representativeField,omitempty"`
	Schema                *PropertySchema        `json:"schema,omitempty"`
	TranslatedTitle       string                 `json:"translatedTitle"`
}

type PublishProjectInput struct {
	ProjectID ID                `json:"projectId"`
	Alias     *string           `json:"alias,omitempty"`
	Status    PublishmentStatus `json:"status"`
}

type PublishStoryInput struct {
	StoryID ID                `json:"storyId"`
	Alias   *string           `json:"alias,omitempty"`
	Status  PublishmentStatus `json:"status"`
}

type Query struct {
}

type Rect struct {
	West  float64 `json:"west"`
	South float64 `json:"south"`
	East  float64 `json:"east"`
	North float64 `json:"north"`
}

type RemoveAssetInput struct {
	AssetID ID `json:"assetId"`
}

type RemoveAssetPayload struct {
	AssetID ID `json:"assetId"`
}

type RemoveClusterInput struct {
	ClusterID ID `json:"clusterId"`
	SceneID   ID `json:"sceneId"`
}

type RemoveClusterPayload struct {
	Scene     *Scene `json:"scene"`
	ClusterID ID     `json:"clusterId"`
}

type RemoveDatasetSchemaInput struct {
	SchemaID ID    `json:"schemaId"`
	Force    *bool `json:"force,omitempty"`
}

type RemoveDatasetSchemaPayload struct {
	SchemaID ID `json:"schemaId"`
}

type RemoveInfoboxFieldInput struct {
	LayerID        ID `json:"layerId"`
	InfoboxFieldID ID `json:"infoboxFieldId"`
}

type RemoveInfoboxFieldPayload struct {
	InfoboxFieldID ID    `json:"infoboxFieldId"`
	Layer          Layer `json:"layer"`
}

type RemoveInfoboxInput struct {
	LayerID ID `json:"layerId"`
}

type RemoveInfoboxPayload struct {
	Layer Layer `json:"layer"`
}

type RemoveLayerInput struct {
	LayerID ID `json:"layerId"`
}

type RemoveLayerPayload struct {
	LayerID     ID          `json:"layerId"`
	ParentLayer *LayerGroup `json:"parentLayer"`
}

type RemoveMemberFromTeamInput struct {
	TeamID ID `json:"teamId"`
	UserID ID `json:"userId"`
}

type RemoveMemberFromTeamPayload struct {
	Team *Team `json:"team"`
}

type RemoveMyAuthInput struct {
	Auth string `json:"auth"`
}

type RemoveNLSInfoboxBlockInput struct {
	LayerID        ID `json:"layerId"`
	InfoboxBlockID ID `json:"infoboxBlockId"`
}

type RemoveNLSInfoboxBlockPayload struct {
	InfoboxBlockID ID       `json:"infoboxBlockId"`
	Layer          NLSLayer `json:"layer"`
}

type RemoveNLSInfoboxInput struct {
	LayerID ID `json:"layerId"`
}

type RemoveNLSInfoboxPayload struct {
	Layer NLSLayer `json:"layer"`
}

type RemoveNLSLayerInput struct {
	LayerID ID `json:"layerId"`
}

type RemoveNLSLayerPayload struct {
	LayerID ID `json:"layerId"`
}

type RemovePropertyFieldInput struct {
	PropertyID    ID  `json:"propertyId"`
	SchemaGroupID *ID `json:"schemaGroupId,omitempty"`
	ItemID        *ID `json:"itemId,omitempty"`
	FieldID       ID  `json:"fieldId"`
}

type RemovePropertyItemInput struct {
	PropertyID    ID `json:"propertyId"`
	SchemaGroupID ID `json:"schemaGroupId"`
	ItemID        ID `json:"itemId"`
}

type RemoveStoryBlockInput struct {
	StoryID ID `json:"storyId"`
	PageID  ID `json:"pageId"`
	BlockID ID `json:"blockId"`
}

type RemoveStoryBlockPayload struct {
	BlockID ID         `json:"blockId"`
	Page    *StoryPage `json:"page"`
	Story   *Story     `json:"story"`
}

type RemoveStyleInput struct {
	StyleID ID `json:"styleId"`
}

type RemoveStylePayload struct {
	StyleID ID `json:"styleId"`
}

type RemoveTagInput struct {
	TagID ID `json:"tagID"`
}

type RemoveTagPayload struct {
	TagID         ID      `json:"tagId"`
	UpdatedLayers []Layer `json:"updatedLayers"`
}

type RemoveWidgetInput struct {
	SceneID  ID `json:"sceneId"`
	WidgetID ID `json:"widgetId"`
}

type RemoveWidgetPayload struct {
	Scene    *Scene `json:"scene"`
	WidgetID ID     `json:"widgetId"`
}

type Scene struct {
	ID                ID                       `json:"id"`
	ProjectID         ID                       `json:"projectId"`
	TeamID            ID                       `json:"teamId"`
	PropertyID        ID                       `json:"propertyId"`
	CreatedAt         time.Time                `json:"createdAt"`
	UpdatedAt         time.Time                `json:"updatedAt"`
	RootLayerID       ID                       `json:"rootLayerId"`
	Widgets           []*SceneWidget           `json:"widgets"`
	Plugins           []*ScenePlugin           `json:"plugins"`
	WidgetAlignSystem *WidgetAlignSystem       `json:"widgetAlignSystem,omitempty"`
	Project           *Project                 `json:"project,omitempty"`
	Team              *Team                    `json:"team,omitempty"`
	Property          *Property                `json:"property,omitempty"`
	RootLayer         *LayerGroup              `json:"rootLayer,omitempty"`
	NewLayers         []NLSLayer               `json:"newLayers"`
	Stories           []*Story                 `json:"stories"`
	Styles            []*Style                 `json:"styles"`
	DatasetSchemas    *DatasetSchemaConnection `json:"datasetSchemas"`
	TagIds            []ID                     `json:"tagIds"`
	Tags              []Tag                    `json:"tags"`
	Clusters          []*Cluster               `json:"clusters"`
}

func (Scene) IsNode()        {}
func (this Scene) GetID() ID { return this.ID }

type ScenePlugin struct {
	PluginID   ID        `json:"pluginId"`
	PropertyID *ID       `json:"propertyId,omitempty"`
	Plugin     *Plugin   `json:"plugin,omitempty"`
	Property   *Property `json:"property,omitempty"`
}

type SceneWidget struct {
	ID          ID               `json:"id"`
	PluginID    ID               `json:"pluginId"`
	ExtensionID ID               `json:"extensionId"`
	PropertyID  ID               `json:"propertyId"`
	Enabled     bool             `json:"enabled"`
	Extended    bool             `json:"extended"`
	Plugin      *Plugin          `json:"plugin,omitempty"`
	Extension   *PluginExtension `json:"extension,omitempty"`
	Property    *Property        `json:"property,omitempty"`
}

type SignupInput struct {
	Lang   *language.Tag `json:"lang,omitempty"`
	Theme  *Theme        `json:"theme,omitempty"`
	UserID *ID           `json:"userId,omitempty"`
	TeamID *ID           `json:"teamId,omitempty"`
	Secret *string       `json:"secret,omitempty"`
}

type SignupPayload struct {
	User *User `json:"user"`
	Team *Team `json:"team"`
}

type Spacing struct {
	Top    float64 `json:"top"`
	Bottom float64 `json:"bottom"`
	Left   float64 `json:"left"`
	Right  float64 `json:"right"`
}

type Story struct {
	ID                ID                `json:"id"`
	Title             string            `json:"title"`
	Alias             string            `json:"alias"`
	PropertyID        ID                `json:"propertyId"`
	Property          *Property         `json:"property,omitempty"`
	Pages             []*StoryPage      `json:"pages"`
	PublishmentStatus PublishmentStatus `json:"publishmentStatus"`
	CreatedAt         time.Time         `json:"createdAt"`
	UpdatedAt         time.Time         `json:"updatedAt"`
	PublishedAt       *time.Time        `json:"publishedAt,omitempty"`
	SceneID           ID                `json:"sceneId"`
	Scene             *Scene            `json:"scene,omitempty"`
	PanelPosition     Position          `json:"panelPosition"`
	BgColor           *string           `json:"bgColor,omitempty"`
	IsBasicAuthActive bool              `json:"isBasicAuthActive"`
	BasicAuthUsername string            `json:"basicAuthUsername"`
	BasicAuthPassword string            `json:"basicAuthPassword"`
	PublicTitle       string            `json:"publicTitle"`
	PublicDescription string            `json:"publicDescription"`
	PublicImage       string            `json:"publicImage"`
	PublicNoIndex     bool              `json:"publicNoIndex"`
}

func (Story) IsNode()        {}
func (this Story) GetID() ID { return this.ID }

type StoryBlock struct {
	ID              ID               `json:"id"`
	PluginID        ID               `json:"pluginId"`
	Plugin          *Plugin          `json:"plugin,omitempty"`
	ExtensionID     ID               `json:"extensionId"`
	Extension       *PluginExtension `json:"extension,omitempty"`
	PropertyID      ID               `json:"propertyId"`
	Property        *Property        `json:"property,omitempty"`
	LinkedDatasetID *ID              `json:"linkedDatasetId,omitempty"`
}

func (StoryBlock) IsNode()        {}
func (this StoryBlock) GetID() ID { return this.ID }

type StoryPage struct {
	ID                 ID            `json:"id"`
	Title              string        `json:"title"`
	Blocks             []*StoryBlock `json:"blocks"`
	Swipeable          bool          `json:"swipeable"`
	LayersIds          []ID          `json:"layersIds"`
	Layers             []Layer       `json:"layers"`
	SwipeableLayersIds []ID          `json:"swipeableLayersIds,omitempty"`
	SwipeableLayers    []Layer       `json:"swipeableLayers,omitempty"`
	PropertyID         ID            `json:"propertyId"`
	Property           *Property     `json:"property,omitempty"`
	CreatedAt          time.Time     `json:"createdAt"`
	SceneID            ID            `json:"sceneId"`
	Scene              *Scene        `json:"scene,omitempty"`
}

func (StoryPage) IsNode()        {}
func (this StoryPage) GetID() ID { return this.ID }

type StoryPagePayload struct {
	Page  *StoryPage `json:"page"`
	Story *Story     `json:"story"`
}

type StoryPayload struct {
	Story *Story `json:"story"`
}

type Style struct {
	ID      ID     `json:"id"`
	Name    string `json:"name"`
	Value   JSON   `json:"value"`
	SceneID ID     `json:"sceneId"`
	Scene   *Scene `json:"scene,omitempty"`
}

type SyncDatasetInput struct {
	SceneID ID     `json:"sceneId"`
	URL     string `json:"url"`
}

type SyncDatasetPayload struct {
	SceneID       ID               `json:"sceneId"`
	URL           string           `json:"url"`
	DatasetSchema []*DatasetSchema `json:"datasetSchema"`
	Dataset       []*Dataset       `json:"dataset"`
}

type TagGroup struct {
	ID      ID         `json:"id"`
	SceneID ID         `json:"sceneId"`
	Label   string     `json:"label"`
	TagIds  []ID       `json:"tagIds,omitempty"`
	Tags    []*TagItem `json:"tags"`
	Scene   *Scene     `json:"scene,omitempty"`
	Layers  []Layer    `json:"layers"`
}

func (TagGroup) IsTag()                {}
func (this TagGroup) GetID() ID        { return this.ID }
func (this TagGroup) GetSceneID() ID   { return this.SceneID }
func (this TagGroup) GetLabel() string { return this.Label }
func (this TagGroup) GetLayers() []Layer {
	if this.Layers == nil {
		return nil
	}
	interfaceSlice := make([]Layer, 0, len(this.Layers))
	for _, concrete := range this.Layers {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type TagItem struct {
	ID                    ID             `json:"id"`
	SceneID               ID             `json:"sceneId"`
	Label                 string         `json:"label"`
	ParentID              *ID            `json:"parentId,omitempty"`
	LinkedDatasetID       *ID            `json:"linkedDatasetID,omitempty"`
	LinkedDatasetSchemaID *ID            `json:"linkedDatasetSchemaID,omitempty"`
	LinkedDatasetFieldID  *ID            `json:"linkedDatasetFieldID,omitempty"`
	LinkedDatasetSchema   *DatasetSchema `json:"linkedDatasetSchema,omitempty"`
	LinkedDataset         *Dataset       `json:"linkedDataset,omitempty"`
	LinkedDatasetField    *DatasetField  `json:"linkedDatasetField,omitempty"`
	Parent                *TagGroup      `json:"parent,omitempty"`
	Layers                []Layer        `json:"layers"`
}

func (TagItem) IsTag()                {}
func (this TagItem) GetID() ID        { return this.ID }
func (this TagItem) GetSceneID() ID   { return this.SceneID }
func (this TagItem) GetLabel() string { return this.Label }
func (this TagItem) GetLayers() []Layer {
	if this.Layers == nil {
		return nil
	}
	interfaceSlice := make([]Layer, 0, len(this.Layers))
	for _, concrete := range this.Layers {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type Team struct {
	ID       ID                 `json:"id"`
	Name     string             `json:"name"`
	Members  []*TeamMember      `json:"members"`
	Personal bool               `json:"personal"`
	PolicyID *ID                `json:"policyId,omitempty"`
	Policy   *Policy            `json:"policy,omitempty"`
	Assets   *AssetConnection   `json:"assets"`
	Projects *ProjectConnection `json:"projects"`
}

func (Team) IsNode()        {}
func (this Team) GetID() ID { return this.ID }

type TeamMember struct {
	UserID ID    `json:"userId"`
	Role   Role  `json:"role"`
	User   *User `json:"user,omitempty"`
}

type Timeline struct {
	CurrentTime *string `json:"currentTime,omitempty"`
	StartTime   *string `json:"startTime,omitempty"`
	EndTime     *string `json:"endTime,omitempty"`
}

type Typography struct {
	FontFamily *string    `json:"fontFamily,omitempty"`
	FontWeight *string    `json:"fontWeight,omitempty"`
	FontSize   *int       `json:"fontSize,omitempty"`
	Color      *string    `json:"color,omitempty"`
	TextAlign  *TextAlign `json:"textAlign,omitempty"`
	Bold       *bool      `json:"bold,omitempty"`
	Italic     *bool      `json:"italic,omitempty"`
	Underline  *bool      `json:"underline,omitempty"`
}

type UninstallPluginInput struct {
	SceneID  ID `json:"sceneId"`
	PluginID ID `json:"pluginId"`
}

type UninstallPluginPayload struct {
	PluginID ID     `json:"pluginId"`
	Scene    *Scene `json:"scene"`
}

type UnlinkPropertyValueInput struct {
	PropertyID    ID  `json:"propertyId"`
	SchemaGroupID *ID `json:"schemaGroupId,omitempty"`
	ItemID        *ID `json:"itemId,omitempty"`
	FieldID       ID  `json:"fieldId"`
}

type UpdateClusterInput struct {
	ClusterID  ID      `json:"clusterId"`
	SceneID    ID      `json:"sceneId"`
	Name       *string `json:"name,omitempty"`
	PropertyID *ID     `json:"propertyId,omitempty"`
}

type UpdateClusterPayload struct {
	Scene   *Scene   `json:"scene"`
	Cluster *Cluster `json:"cluster"`
}

type UpdateDatasetSchemaInput struct {
	SchemaID ID     `json:"schemaId"`
	Name     string `json:"name"`
}

type UpdateDatasetSchemaPayload struct {
	DatasetSchema *DatasetSchema `json:"datasetSchema,omitempty"`
}

type UpdateLayerInput struct {
	LayerID ID      `json:"layerId"`
	Name    *string `json:"name,omitempty"`
	Visible *bool   `json:"visible,omitempty"`
}

type UpdateLayerPayload struct {
	Layer Layer `json:"layer"`
}

type UpdateMeInput struct {
	Name                 *string       `json:"name,omitempty"`
	Email                *string       `json:"email,omitempty"`
	Lang                 *language.Tag `json:"lang,omitempty"`
	Theme                *Theme        `json:"theme,omitempty"`
	Password             *string       `json:"password,omitempty"`
	PasswordConfirmation *string       `json:"passwordConfirmation,omitempty"`
}

type UpdateMePayload struct {
	Me *Me `json:"me"`
}

type UpdateMemberOfTeamInput struct {
	TeamID ID   `json:"teamId"`
	UserID ID   `json:"userId"`
	Role   Role `json:"role"`
}

type UpdateMemberOfTeamPayload struct {
	Team *Team `json:"team"`
}

type UpdateNLSLayerInput struct {
	LayerID ID      `json:"layerId"`
	Name    *string `json:"name,omitempty"`
	Visible *bool   `json:"visible,omitempty"`
	Config  JSON    `json:"config,omitempty"`
}

type UpdateNLSLayerPayload struct {
	Layer NLSLayer `json:"layer"`
}

type UpdateProjectInput struct {
	ProjectID         ID       `json:"projectId"`
	Name              *string  `json:"name,omitempty"`
	Description       *string  `json:"description,omitempty"`
	Archived          *bool    `json:"archived,omitempty"`
	IsBasicAuthActive *bool    `json:"isBasicAuthActive,omitempty"`
	BasicAuthUsername *string  `json:"basicAuthUsername,omitempty"`
	BasicAuthPassword *string  `json:"basicAuthPassword,omitempty"`
	Alias             *string  `json:"alias,omitempty"`
	ImageURL          *url.URL `json:"imageUrl,omitempty"`
	PublicTitle       *string  `json:"publicTitle,omitempty"`
	PublicDescription *string  `json:"publicDescription,omitempty"`
	PublicImage       *string  `json:"publicImage,omitempty"`
	PublicNoIndex     *bool    `json:"publicNoIndex,omitempty"`
	DeleteImageURL    *bool    `json:"deleteImageUrl,omitempty"`
	DeletePublicImage *bool    `json:"deletePublicImage,omitempty"`
	EnableGa          *bool    `json:"enableGa,omitempty"`
	TrackingID        *string  `json:"trackingId,omitempty"`
	SceneID           *ID      `json:"sceneId,omitempty"`
}

type UpdatePropertyItemInput struct {
	PropertyID    ID                                  `json:"propertyId"`
	SchemaGroupID ID                                  `json:"schemaGroupId"`
	Operations    []*UpdatePropertyItemOperationInput `json:"operations"`
}

type UpdatePropertyItemOperationInput struct {
	Operation      ListOperation `json:"operation"`
	ItemID         *ID           `json:"itemId,omitempty"`
	Index          *int          `json:"index,omitempty"`
	NameFieldValue interface{}   `json:"nameFieldValue,omitempty"`
	NameFieldType  *ValueType    `json:"nameFieldType,omitempty"`
}

type UpdatePropertyValueInput struct {
	PropertyID    ID          `json:"propertyId"`
	SchemaGroupID *ID         `json:"schemaGroupId,omitempty"`
	ItemID        *ID         `json:"itemId,omitempty"`
	FieldID       ID          `json:"fieldId"`
	Value         interface{} `json:"value,omitempty"`
	Type          ValueType   `json:"type"`
}

type UpdateStoryInput struct {
	SceneID           ID        `json:"sceneId"`
	StoryID           ID        `json:"storyId"`
	Title             *string   `json:"title,omitempty"`
	Index             *int      `json:"index,omitempty"`
	PanelPosition     *Position `json:"panelPosition,omitempty"`
	BgColor           *string   `json:"bgColor,omitempty"`
	IsBasicAuthActive *bool     `json:"isBasicAuthActive,omitempty"`
	BasicAuthUsername *string   `json:"basicAuthUsername,omitempty"`
	BasicAuthPassword *string   `json:"basicAuthPassword,omitempty"`
	Alias             *string   `json:"alias,omitempty"`
	PublicTitle       *string   `json:"publicTitle,omitempty"`
	PublicDescription *string   `json:"publicDescription,omitempty"`
	PublicImage       *string   `json:"publicImage,omitempty"`
	PublicNoIndex     *bool     `json:"publicNoIndex,omitempty"`
	DeletePublicImage *bool     `json:"deletePublicImage,omitempty"`
}

type UpdateStoryPageInput struct {
	SceneID         ID      `json:"sceneId"`
	StoryID         ID      `json:"storyId"`
	PageID          ID      `json:"pageId"`
	Title           *string `json:"title,omitempty"`
	Swipeable       *bool   `json:"swipeable,omitempty"`
	Layers          []ID    `json:"layers,omitempty"`
	SwipeableLayers []ID    `json:"swipeableLayers,omitempty"`
	Index           *int    `json:"index,omitempty"`
}

type UpdateStyleInput struct {
	StyleID ID      `json:"styleId"`
	Name    *string `json:"name,omitempty"`
	Value   JSON    `json:"value,omitempty"`
}

type UpdateStylePayload struct {
	Style *Style `json:"style"`
}

type UpdateTagInput struct {
	TagID   ID      `json:"tagId"`
	SceneID ID      `json:"sceneId"`
	Label   *string `json:"label,omitempty"`
}

type UpdateTagPayload struct {
	Tag Tag `json:"tag"`
}

type UpdateTeamInput struct {
	TeamID ID     `json:"teamId"`
	Name   string `json:"name"`
}

type UpdateTeamPayload struct {
	Team *Team `json:"team"`
}

type UpdateWidgetAlignSystemInput struct {
	SceneID    ID                      `json:"sceneId"`
	Location   *WidgetLocationInput    `json:"location"`
	Align      *WidgetAreaAlign        `json:"align,omitempty"`
	Padding    *WidgetAreaPaddingInput `json:"padding,omitempty"`
	Gap        *int                    `json:"gap,omitempty"`
	Centered   *bool                   `json:"centered,omitempty"`
	Background *string                 `json:"background,omitempty"`
}

type UpdateWidgetAlignSystemPayload struct {
	Scene *Scene `json:"scene"`
}

type UpdateWidgetInput struct {
	SceneID  ID                   `json:"sceneId"`
	WidgetID ID                   `json:"widgetId"`
	Enabled  *bool                `json:"enabled,omitempty"`
	Location *WidgetLocationInput `json:"location,omitempty"`
	Extended *bool                `json:"extended,omitempty"`
	Index    *int                 `json:"index,omitempty"`
}

type UpdateWidgetPayload struct {
	Scene       *Scene       `json:"scene"`
	SceneWidget *SceneWidget `json:"sceneWidget"`
}

type UpgradePluginInput struct {
	SceneID    ID `json:"sceneId"`
	PluginID   ID `json:"pluginId"`
	ToPluginID ID `json:"toPluginId"`
}

type UpgradePluginPayload struct {
	Scene       *Scene       `json:"scene"`
	ScenePlugin *ScenePlugin `json:"scenePlugin"`
}

type UploadFileToPropertyInput struct {
	PropertyID    ID             `json:"propertyId"`
	SchemaGroupID *ID            `json:"schemaGroupId,omitempty"`
	ItemID        *ID            `json:"itemId,omitempty"`
	FieldID       ID             `json:"fieldId"`
	File          graphql.Upload `json:"file"`
}

type UploadPluginInput struct {
	SceneID ID              `json:"sceneId"`
	File    *graphql.Upload `json:"file,omitempty"`
	URL     *url.URL        `json:"url,omitempty"`
}

type UploadPluginPayload struct {
	Plugin      *Plugin      `json:"plugin"`
	Scene       *Scene       `json:"scene"`
	ScenePlugin *ScenePlugin `json:"scenePlugin"`
}

type User struct {
	ID    ID      `json:"id"`
	Name  string  `json:"name"`
	Email string  `json:"email"`
	Host  *string `json:"host,omitempty"`
}

func (User) IsNode()        {}
func (this User) GetID() ID { return this.ID }

type WidgetAlignSystem struct {
	Inner *WidgetZone `json:"inner,omitempty"`
	Outer *WidgetZone `json:"outer,omitempty"`
}

type WidgetArea struct {
	WidgetIds  []ID               `json:"widgetIds"`
	Align      WidgetAreaAlign    `json:"align"`
	Padding    *WidgetAreaPadding `json:"padding,omitempty"`
	Gap        *int               `json:"gap,omitempty"`
	Centered   bool               `json:"centered"`
	Background *string            `json:"background,omitempty"`
}

type WidgetAreaPadding struct {
	Top    int `json:"top"`
	Bottom int `json:"bottom"`
	Left   int `json:"left"`
	Right  int `json:"right"`
}

type WidgetAreaPaddingInput struct {
	Top    int `json:"top"`
	Bottom int `json:"bottom"`
	Left   int `json:"left"`
	Right  int `json:"right"`
}

type WidgetExtendable struct {
	Vertically   bool `json:"vertically"`
	Horizontally bool `json:"horizontally"`
}

type WidgetLayout struct {
	Extendable      *WidgetExtendable `json:"extendable"`
	Extended        bool              `json:"extended"`
	Floating        bool              `json:"floating"`
	DefaultLocation *WidgetLocation   `json:"defaultLocation,omitempty"`
}

type WidgetLocation struct {
	Zone    WidgetZoneType    `json:"zone"`
	Section WidgetSectionType `json:"section"`
	Area    WidgetAreaType    `json:"area"`
}

type WidgetLocationInput struct {
	Zone    WidgetZoneType    `json:"zone"`
	Section WidgetSectionType `json:"section"`
	Area    WidgetAreaType    `json:"area"`
}

type WidgetSection struct {
	Top    *WidgetArea `json:"top,omitempty"`
	Middle *WidgetArea `json:"middle,omitempty"`
	Bottom *WidgetArea `json:"bottom,omitempty"`
}

type WidgetZone struct {
	Left   *WidgetSection `json:"left,omitempty"`
	Center *WidgetSection `json:"center,omitempty"`
	Right  *WidgetSection `json:"right,omitempty"`
}

type AssetSortType string

const (
	AssetSortTypeDate AssetSortType = "DATE"
	AssetSortTypeSize AssetSortType = "SIZE"
	AssetSortTypeName AssetSortType = "NAME"
)

var AllAssetSortType = []AssetSortType{
	AssetSortTypeDate,
	AssetSortTypeSize,
	AssetSortTypeName,
}

func (e AssetSortType) IsValid() bool {
	switch e {
	case AssetSortTypeDate, AssetSortTypeSize, AssetSortTypeName:
		return true
	}
	return false
}

func (e AssetSortType) String() string {
	return string(e)
}

func (e *AssetSortType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AssetSortType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AssetSortType", str)
	}
	return nil
}

func (e AssetSortType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LayerEncodingFormat string

const (
	LayerEncodingFormatKml     LayerEncodingFormat = "KML"
	LayerEncodingFormatCzml    LayerEncodingFormat = "CZML"
	LayerEncodingFormatGeojson LayerEncodingFormat = "GEOJSON"
	LayerEncodingFormatShape   LayerEncodingFormat = "SHAPE"
	LayerEncodingFormatReearth LayerEncodingFormat = "REEARTH"
)

var AllLayerEncodingFormat = []LayerEncodingFormat{
	LayerEncodingFormatKml,
	LayerEncodingFormatCzml,
	LayerEncodingFormatGeojson,
	LayerEncodingFormatShape,
	LayerEncodingFormatReearth,
}

func (e LayerEncodingFormat) IsValid() bool {
	switch e {
	case LayerEncodingFormatKml, LayerEncodingFormatCzml, LayerEncodingFormatGeojson, LayerEncodingFormatShape, LayerEncodingFormatReearth:
		return true
	}
	return false
}

func (e LayerEncodingFormat) String() string {
	return string(e)
}

func (e *LayerEncodingFormat) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LayerEncodingFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LayerEncodingFormat", str)
	}
	return nil
}

func (e LayerEncodingFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ListOperation string

const (
	ListOperationAdd    ListOperation = "ADD"
	ListOperationMove   ListOperation = "MOVE"
	ListOperationRemove ListOperation = "REMOVE"
)

var AllListOperation = []ListOperation{
	ListOperationAdd,
	ListOperationMove,
	ListOperationRemove,
}

func (e ListOperation) IsValid() bool {
	switch e {
	case ListOperationAdd, ListOperationMove, ListOperationRemove:
		return true
	}
	return false
}

func (e ListOperation) String() string {
	return string(e)
}

func (e *ListOperation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ListOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ListOperation", str)
	}
	return nil
}

func (e ListOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeType string

const (
	NodeTypeAsset          NodeType = "ASSET"
	NodeTypeUser           NodeType = "USER"
	NodeTypeTeam           NodeType = "TEAM"
	NodeTypeProject        NodeType = "PROJECT"
	NodeTypePlugin         NodeType = "PLUGIN"
	NodeTypeScene          NodeType = "SCENE"
	NodeTypePropertySchema NodeType = "PROPERTY_SCHEMA"
	NodeTypeProperty       NodeType = "PROPERTY"
	NodeTypeDatasetSchema  NodeType = "DATASET_SCHEMA"
	NodeTypeDataset        NodeType = "DATASET"
	NodeTypeLayerGroup     NodeType = "LAYER_GROUP"
	NodeTypeLayerItem      NodeType = "LAYER_ITEM"
)

var AllNodeType = []NodeType{
	NodeTypeAsset,
	NodeTypeUser,
	NodeTypeTeam,
	NodeTypeProject,
	NodeTypePlugin,
	NodeTypeScene,
	NodeTypePropertySchema,
	NodeTypeProperty,
	NodeTypeDatasetSchema,
	NodeTypeDataset,
	NodeTypeLayerGroup,
	NodeTypeLayerItem,
}

func (e NodeType) IsValid() bool {
	switch e {
	case NodeTypeAsset, NodeTypeUser, NodeTypeTeam, NodeTypeProject, NodeTypePlugin, NodeTypeScene, NodeTypePropertySchema, NodeTypeProperty, NodeTypeDatasetSchema, NodeTypeDataset, NodeTypeLayerGroup, NodeTypeLayerItem:
		return true
	}
	return false
}

func (e NodeType) String() string {
	return string(e)
}

func (e *NodeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeType", str)
	}
	return nil
}

func (e NodeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PluginExtensionType string

const (
	PluginExtensionTypePrimitive  PluginExtensionType = "PRIMITIVE"
	PluginExtensionTypeWidget     PluginExtensionType = "WIDGET"
	PluginExtensionTypeBlock      PluginExtensionType = "BLOCK"
	PluginExtensionTypeVisualizer PluginExtensionType = "VISUALIZER"
	PluginExtensionTypeInfobox    PluginExtensionType = "INFOBOX"
	PluginExtensionTypeCluster    PluginExtensionType = "Cluster"
	PluginExtensionTypeStory      PluginExtensionType = "Story"
	PluginExtensionTypeStoryPage  PluginExtensionType = "StoryPage"
	PluginExtensionTypeStoryBlock PluginExtensionType = "StoryBlock"
)

var AllPluginExtensionType = []PluginExtensionType{
	PluginExtensionTypePrimitive,
	PluginExtensionTypeWidget,
	PluginExtensionTypeBlock,
	PluginExtensionTypeVisualizer,
	PluginExtensionTypeInfobox,
	PluginExtensionTypeCluster,
	PluginExtensionTypeStory,
	PluginExtensionTypeStoryPage,
	PluginExtensionTypeStoryBlock,
}

func (e PluginExtensionType) IsValid() bool {
	switch e {
	case PluginExtensionTypePrimitive, PluginExtensionTypeWidget, PluginExtensionTypeBlock, PluginExtensionTypeVisualizer, PluginExtensionTypeInfobox, PluginExtensionTypeCluster, PluginExtensionTypeStory, PluginExtensionTypeStoryPage, PluginExtensionTypeStoryBlock:
		return true
	}
	return false
}

func (e PluginExtensionType) String() string {
	return string(e)
}

func (e *PluginExtensionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PluginExtensionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PluginExtensionType", str)
	}
	return nil
}

func (e PluginExtensionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Position string

const (
	PositionLeft  Position = "LEFT"
	PositionRight Position = "RIGHT"
)

var AllPosition = []Position{
	PositionLeft,
	PositionRight,
}

func (e Position) IsValid() bool {
	switch e {
	case PositionLeft, PositionRight:
		return true
	}
	return false
}

func (e Position) String() string {
	return string(e)
}

func (e *Position) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Position(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Position", str)
	}
	return nil
}

func (e Position) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PropertySchemaFieldUI string

const (
	PropertySchemaFieldUILayer      PropertySchemaFieldUI = "LAYER"
	PropertySchemaFieldUIMultiline  PropertySchemaFieldUI = "MULTILINE"
	PropertySchemaFieldUISelection  PropertySchemaFieldUI = "SELECTION"
	PropertySchemaFieldUIColor      PropertySchemaFieldUI = "COLOR"
	PropertySchemaFieldUIRange      PropertySchemaFieldUI = "RANGE"
	PropertySchemaFieldUISlider     PropertySchemaFieldUI = "SLIDER"
	PropertySchemaFieldUIImage      PropertySchemaFieldUI = "IMAGE"
	PropertySchemaFieldUIVideo      PropertySchemaFieldUI = "VIDEO"
	PropertySchemaFieldUIFile       PropertySchemaFieldUI = "FILE"
	PropertySchemaFieldUICameraPose PropertySchemaFieldUI = "CAMERA_POSE"
	PropertySchemaFieldUIDatetime   PropertySchemaFieldUI = "DATETIME"
	PropertySchemaFieldUIMargin     PropertySchemaFieldUI = "MARGIN"
	PropertySchemaFieldUIPadding    PropertySchemaFieldUI = "PADDING"
)

var AllPropertySchemaFieldUI = []PropertySchemaFieldUI{
	PropertySchemaFieldUILayer,
	PropertySchemaFieldUIMultiline,
	PropertySchemaFieldUISelection,
	PropertySchemaFieldUIColor,
	PropertySchemaFieldUIRange,
	PropertySchemaFieldUISlider,
	PropertySchemaFieldUIImage,
	PropertySchemaFieldUIVideo,
	PropertySchemaFieldUIFile,
	PropertySchemaFieldUICameraPose,
	PropertySchemaFieldUIDatetime,
	PropertySchemaFieldUIMargin,
	PropertySchemaFieldUIPadding,
}

func (e PropertySchemaFieldUI) IsValid() bool {
	switch e {
	case PropertySchemaFieldUILayer, PropertySchemaFieldUIMultiline, PropertySchemaFieldUISelection, PropertySchemaFieldUIColor, PropertySchemaFieldUIRange, PropertySchemaFieldUISlider, PropertySchemaFieldUIImage, PropertySchemaFieldUIVideo, PropertySchemaFieldUIFile, PropertySchemaFieldUICameraPose, PropertySchemaFieldUIDatetime, PropertySchemaFieldUIMargin, PropertySchemaFieldUIPadding:
		return true
	}
	return false
}

func (e PropertySchemaFieldUI) String() string {
	return string(e)
}

func (e *PropertySchemaFieldUI) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PropertySchemaFieldUI(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PropertySchemaFieldUI", str)
	}
	return nil
}

func (e PropertySchemaFieldUI) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PublishmentStatus string

const (
	PublishmentStatusPublic  PublishmentStatus = "PUBLIC"
	PublishmentStatusLimited PublishmentStatus = "LIMITED"
	PublishmentStatusPrivate PublishmentStatus = "PRIVATE"
)

var AllPublishmentStatus = []PublishmentStatus{
	PublishmentStatusPublic,
	PublishmentStatusLimited,
	PublishmentStatusPrivate,
}

func (e PublishmentStatus) IsValid() bool {
	switch e {
	case PublishmentStatusPublic, PublishmentStatusLimited, PublishmentStatusPrivate:
		return true
	}
	return false
}

func (e PublishmentStatus) String() string {
	return string(e)
}

func (e *PublishmentStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PublishmentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PublishmentStatus", str)
	}
	return nil
}

func (e PublishmentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Role string

const (
	RoleReader     Role = "READER"
	RoleWriter     Role = "WRITER"
	RoleMaintainer Role = "MAINTAINER"
	RoleOwner      Role = "OWNER"
)

var AllRole = []Role{
	RoleReader,
	RoleWriter,
	RoleMaintainer,
	RoleOwner,
}

func (e Role) IsValid() bool {
	switch e {
	case RoleReader, RoleWriter, RoleMaintainer, RoleOwner:
		return true
	}
	return false
}

func (e Role) String() string {
	return string(e)
}

func (e *Role) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Role(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Role", str)
	}
	return nil
}

func (e Role) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TextAlign string

const (
	TextAlignLeft       TextAlign = "LEFT"
	TextAlignCenter     TextAlign = "CENTER"
	TextAlignRight      TextAlign = "RIGHT"
	TextAlignJustify    TextAlign = "JUSTIFY"
	TextAlignJustifyAll TextAlign = "JUSTIFY_ALL"
)

var AllTextAlign = []TextAlign{
	TextAlignLeft,
	TextAlignCenter,
	TextAlignRight,
	TextAlignJustify,
	TextAlignJustifyAll,
}

func (e TextAlign) IsValid() bool {
	switch e {
	case TextAlignLeft, TextAlignCenter, TextAlignRight, TextAlignJustify, TextAlignJustifyAll:
		return true
	}
	return false
}

func (e TextAlign) String() string {
	return string(e)
}

func (e *TextAlign) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TextAlign(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TextAlign", str)
	}
	return nil
}

func (e TextAlign) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Theme string

const (
	ThemeDefault Theme = "DEFAULT"
	ThemeLight   Theme = "LIGHT"
	ThemeDark    Theme = "DARK"
)

var AllTheme = []Theme{
	ThemeDefault,
	ThemeLight,
	ThemeDark,
}

func (e Theme) IsValid() bool {
	switch e {
	case ThemeDefault, ThemeLight, ThemeDark:
		return true
	}
	return false
}

func (e Theme) String() string {
	return string(e)
}

func (e *Theme) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Theme(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Theme", str)
	}
	return nil
}

func (e Theme) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ValueType string

const (
	ValueTypeBool         ValueType = "BOOL"
	ValueTypeNumber       ValueType = "NUMBER"
	ValueTypeString       ValueType = "STRING"
	ValueTypeRef          ValueType = "REF"
	ValueTypeURL          ValueType = "URL"
	ValueTypeLatlng       ValueType = "LATLNG"
	ValueTypeLatlngheight ValueType = "LATLNGHEIGHT"
	ValueTypeCamera       ValueType = "CAMERA"
	ValueTypeTypography   ValueType = "TYPOGRAPHY"
	ValueTypeCoordinates  ValueType = "COORDINATES"
	ValueTypePolygon      ValueType = "POLYGON"
	ValueTypeRect         ValueType = "RECT"
	ValueTypeSpacing      ValueType = "SPACING"
	ValueTypeArray        ValueType = "ARRAY"
	ValueTypeTimeline     ValueType = "TIMELINE"
)

var AllValueType = []ValueType{
	ValueTypeBool,
	ValueTypeNumber,
	ValueTypeString,
	ValueTypeRef,
	ValueTypeURL,
	ValueTypeLatlng,
	ValueTypeLatlngheight,
	ValueTypeCamera,
	ValueTypeTypography,
	ValueTypeCoordinates,
	ValueTypePolygon,
	ValueTypeRect,
	ValueTypeSpacing,
	ValueTypeArray,
	ValueTypeTimeline,
}

func (e ValueType) IsValid() bool {
	switch e {
	case ValueTypeBool, ValueTypeNumber, ValueTypeString, ValueTypeRef, ValueTypeURL, ValueTypeLatlng, ValueTypeLatlngheight, ValueTypeCamera, ValueTypeTypography, ValueTypeCoordinates, ValueTypePolygon, ValueTypeRect, ValueTypeSpacing, ValueTypeArray, ValueTypeTimeline:
		return true
	}
	return false
}

func (e ValueType) String() string {
	return string(e)
}

func (e *ValueType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValueType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValueType", str)
	}
	return nil
}

func (e ValueType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Visualizer string

const (
	VisualizerCesium Visualizer = "CESIUM"
)

var AllVisualizer = []Visualizer{
	VisualizerCesium,
}

func (e Visualizer) IsValid() bool {
	switch e {
	case VisualizerCesium:
		return true
	}
	return false
}

func (e Visualizer) String() string {
	return string(e)
}

func (e *Visualizer) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Visualizer(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Visualizer", str)
	}
	return nil
}

func (e Visualizer) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WidgetAreaAlign string

const (
	WidgetAreaAlignStart    WidgetAreaAlign = "START"
	WidgetAreaAlignCentered WidgetAreaAlign = "CENTERED"
	WidgetAreaAlignEnd      WidgetAreaAlign = "END"
)

var AllWidgetAreaAlign = []WidgetAreaAlign{
	WidgetAreaAlignStart,
	WidgetAreaAlignCentered,
	WidgetAreaAlignEnd,
}

func (e WidgetAreaAlign) IsValid() bool {
	switch e {
	case WidgetAreaAlignStart, WidgetAreaAlignCentered, WidgetAreaAlignEnd:
		return true
	}
	return false
}

func (e WidgetAreaAlign) String() string {
	return string(e)
}

func (e *WidgetAreaAlign) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WidgetAreaAlign(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WidgetAreaAlign", str)
	}
	return nil
}

func (e WidgetAreaAlign) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WidgetAreaType string

const (
	WidgetAreaTypeTop    WidgetAreaType = "TOP"
	WidgetAreaTypeMiddle WidgetAreaType = "MIDDLE"
	WidgetAreaTypeBottom WidgetAreaType = "BOTTOM"
)

var AllWidgetAreaType = []WidgetAreaType{
	WidgetAreaTypeTop,
	WidgetAreaTypeMiddle,
	WidgetAreaTypeBottom,
}

func (e WidgetAreaType) IsValid() bool {
	switch e {
	case WidgetAreaTypeTop, WidgetAreaTypeMiddle, WidgetAreaTypeBottom:
		return true
	}
	return false
}

func (e WidgetAreaType) String() string {
	return string(e)
}

func (e *WidgetAreaType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WidgetAreaType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WidgetAreaType", str)
	}
	return nil
}

func (e WidgetAreaType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WidgetSectionType string

const (
	WidgetSectionTypeLeft   WidgetSectionType = "LEFT"
	WidgetSectionTypeCenter WidgetSectionType = "CENTER"
	WidgetSectionTypeRight  WidgetSectionType = "RIGHT"
)

var AllWidgetSectionType = []WidgetSectionType{
	WidgetSectionTypeLeft,
	WidgetSectionTypeCenter,
	WidgetSectionTypeRight,
}

func (e WidgetSectionType) IsValid() bool {
	switch e {
	case WidgetSectionTypeLeft, WidgetSectionTypeCenter, WidgetSectionTypeRight:
		return true
	}
	return false
}

func (e WidgetSectionType) String() string {
	return string(e)
}

func (e *WidgetSectionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WidgetSectionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WidgetSectionType", str)
	}
	return nil
}

func (e WidgetSectionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WidgetZoneType string

const (
	WidgetZoneTypeInner WidgetZoneType = "INNER"
	WidgetZoneTypeOuter WidgetZoneType = "OUTER"
)

var AllWidgetZoneType = []WidgetZoneType{
	WidgetZoneTypeInner,
	WidgetZoneTypeOuter,
}

func (e WidgetZoneType) IsValid() bool {
	switch e {
	case WidgetZoneTypeInner, WidgetZoneTypeOuter:
		return true
	}
	return false
}

func (e WidgetZoneType) String() string {
	return string(e)
}

func (e *WidgetZoneType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WidgetZoneType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WidgetZoneType", str)
	}
	return nil
}

func (e WidgetZoneType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
