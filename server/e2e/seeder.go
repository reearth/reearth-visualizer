//go:build e2e

package e2e

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"mime"
	"net/url"
	"os"
	"path/filepath"
	"time"

	"github.com/reearth/reearth/server/internal/adapter/gql/gqlmodel"
	"github.com/reearth/reearth/server/internal/usecase/gateway"
	"github.com/reearth/reearth/server/internal/usecase/repo"
	"github.com/reearth/reearth/server/pkg/asset"
	"github.com/reearth/reearth/server/pkg/builtin"
	"github.com/reearth/reearth/server/pkg/file"
	"github.com/reearth/reearth/server/pkg/id"
	"github.com/reearth/reearth/server/pkg/nlslayer"
	"github.com/reearth/reearth/server/pkg/plugin"
	"github.com/reearth/reearth/server/pkg/project"
	"github.com/reearth/reearth/server/pkg/property"
	"github.com/reearth/reearth/server/pkg/scene"
	"github.com/reearth/reearth/server/pkg/storytelling"
	"github.com/reearth/reearth/server/pkg/visualizer"
	"github.com/reearth/reearthx/util"
	"golang.org/x/text/language"

	accountsGQLclient "github.com/reearth/reearth-accounts/server/pkg/gqlclient"
	accountsID "github.com/reearth/reearth-accounts/server/pkg/id"
	accountsRole "github.com/reearth/reearth-accounts/server/pkg/role"
	accountsUser "github.com/reearth/reearth-accounts/server/pkg/user"
	accountsWorkspace "github.com/reearth/reearth-accounts/server/pkg/workspace"
)

// SeederResult holds the IDs generated by the seeder
type SeederResult struct {
	// User 1
	WID    accountsID.WorkspaceID
	WAlias string
	UID    accountsID.UserID
	UName  string
	UEmail string

	// User 2
	WID2    accountsID.WorkspaceID
	WAlias2 string
	UID2    accountsID.UserID
	UName2  string
	UEmail2 string

	// User 3
	WID3    accountsID.WorkspaceID
	WAlias3 string
	UID3    accountsID.UserID
	UName3  string
	UEmail3 string

	// Project and Scene
	PID    id.ProjectID
	PName  string
	PDesc  string
	PAlias string
	SID    id.SceneID

	// Other IDs
	NLSLayerID id.NLSLayerID
	StoryID    id.StoryID
	PageID     id.PageID
	BlockID    id.BlockID
}

// newSeederResult creates a new SeederResult with unique IDs
func newSeederResult() *SeederResult {
	// Generate a highly unique suffix using timestamp + random bytes for email uniqueness
	// This ensures that even if tests run in parallel or sequentially, emails will be unique
	randomBytes := make([]byte, 8)
	if _, err := rand.Read(randomBytes); err != nil {
		panic(fmt.Sprintf("failed to generate random bytes: %v", err))
	}
	timestamp := time.Now().UnixNano()
	uniqueSuffix := fmt.Sprintf("%d%s", timestamp, hex.EncodeToString(randomBytes))

	return &SeederResult{
		// User 1
		WID:    accountsID.NewWorkspaceID(),
		WAlias: fmt.Sprintf("workspace-alias-%s", uniqueSuffix),
		UID:    accountsID.NewUserID(),
		UName:  fmt.Sprintf("e2e-%s", uniqueSuffix),
		UEmail: fmt.Sprintf("e2e+%s@e2e.com", uniqueSuffix),

		// User 2
		WID2:    accountsID.NewWorkspaceID(),
		WAlias2: fmt.Sprintf("workspace-alias-2-%s", uniqueSuffix),
		UID2:    accountsID.NewUserID(),
		UName2:  fmt.Sprintf("e3e-%s", uniqueSuffix),
		UEmail2: fmt.Sprintf("e3e+%s@e3e.com", uniqueSuffix),

		// User 3
		WID3:    accountsID.NewWorkspaceID(),
		WAlias3: fmt.Sprintf("workspace-alias-3-%s", uniqueSuffix),
		UID3:    accountsID.NewUserID(),
		UName3:  fmt.Sprintf("e4e-%s", uniqueSuffix),
		UEmail3: fmt.Sprintf("e4e+%s@e4e.com", uniqueSuffix),

		// Project and Scene
		PID:    id.NewProjectID(),
		PName:  "p1",
		PDesc:  "p1 desc",
		PAlias: "PROJECT_ALIAS",
		SID:    id.NewSceneID(),

		// Other IDs
		NLSLayerID: id.NewNLSLayerID(),
		StoryID:    id.NewStoryID(),
		PageID:     id.NewPageID(),
		BlockID:    id.NewBlockID(),
	}
}

var (
	now = time.Date(2022, time.January, 1, 0, 0, 0, 0, time.UTC)
)

func setupUserAndWorkspace(ctx context.Context, r *repo.Container, f gateway.File, accountsClient *accountsGQLclient.Client, result *SeederResult) error {
	// Use accounts API client to create users and workspaces
	// The API may return different IDs than we requested, so we need to update result
	actualUID, actualWID, err := createUserAndWorkspaceViaAPI(ctx, accountsClient, result.WID, result.WAlias, result.UID, result.UName, result.UEmail, "Password123!", "")
	if err != nil {
		return err
	}
	// Update result with actual IDs from accounts service
	if actualUID != nil {
		result.UID = *actualUID
	}
	if actualWID != nil {
		result.WID = *actualWID
	}

	user1, err := seedAccountRepoUserWorkspace(ctx, r, result.UID, result.WID, result.UName, result.UEmail, result.WAlias)
	if err != nil {
		return err
	}

	if err := baseSetup(ctx, r, f, result); err != nil {
		return err
	}

	actualUID2, actualWID2, err := createUserAndWorkspaceViaAPI(ctx, accountsClient, result.WID2, result.WAlias2, result.UID2, result.UName2, result.UEmail2, "Password123!", "")
	if err != nil {
		return err
	}
	// Update result with actual IDs from accounts service
	if actualUID2 != nil {
		result.UID2 = *actualUID2
	}
	if actualWID2 != nil {
		result.WID2 = *actualWID2
	}

	if _, err := seedAccountRepoUserWorkspace(ctx, r, result.UID2, result.WID2, result.UName2, result.UEmail2, result.WAlias2); err != nil {
		return err
	}

	actualUID3, actualWID3, err := createUserAndWorkspaceViaAPI(ctx, accountsClient, result.WID3, result.WAlias3, result.UID3, result.UName3, result.UEmail3, "Password123!", "")
	if err != nil {
		return err
	}
	// Update result with actual IDs from accounts service
	if actualUID3 != nil {
		result.UID3 = *actualUID3
	}
	if actualWID3 != nil {
		result.WID3 = *actualWID3
	}

	user3, err := seedAccountRepoUserWorkspace(ctx, r, result.UID3, result.WID3, result.UName3, result.UEmail3, result.WAlias3)
	if err != nil {
		return err
	}

	// assign user3 to user1's workspace
	if err := addUserToWorkspaceViaAPI(ctx, accountsClient, result.WID, result.UID3, "reader", result.UID); err != nil {
		return err
	}
	if user1 != nil && user3 != nil {
		if err := JoinMembers(ctx, r, result.WID, user3, accountsRole.RoleReader, result.UID); err != nil {
			return err
		}
	}

	return nil
}

func seedAccountRepoUserWorkspace(
	ctx context.Context,
	r *repo.Container,
	uid accountsID.UserID,
	wid accountsID.WorkspaceID,
	name string,
	email string,
	alias string,
) (*accountsUser.User, error) {
	if r == nil || r.User == nil || r.Workspace == nil {
		return nil, nil
	}

	u := accountsUser.New().
		ID(uid).
		Name(name).
		Email(email).
		Workspace(wid).
		Metadata(accountsUser.NewMetadata()).
		MustBuild()
	if err := r.User.Save(ctx, u); err != nil {
		return nil, err
	}

	members := map[accountsID.UserID]accountsWorkspace.Member{
		uid: {
			Role:      accountsRole.RoleOwner,
			InvitedBy: uid,
		},
	}
	w := accountsWorkspace.New().
		ID(wid).
		Name(name).
		Alias(alias).
		Members(members).
		Metadata(accountsWorkspace.MetadataFrom("", "", "", "", "")).
		Personal(false).
		MustBuild()
	if err := r.Workspace.Save(ctx, w); err != nil {
		return nil, err
	}

	return u, nil
}

func baseSeeder(ctx context.Context, r *repo.Container, f gateway.File, accountsClient *accountsGQLclient.Client, result *SeederResult) error {
	defer util.MockNow(now)()

	if err := setupUserAndWorkspace(ctx, r, f, accountsClient, result); err != nil {
		return err
	}

	if err := baseSetup(ctx, r, f, result); err != nil {
		return err
	}

	return nil
}

func fullSeeder(ctx context.Context, r *repo.Container, f gateway.File, accountsClient *accountsGQLclient.Client, result *SeederResult) error {
	defer util.MockNow(now)()

	if err := setupUserAndWorkspace(ctx, r, f, accountsClient, result); err != nil {
		return err
	}

	if err := baseSetup(ctx, r, f, result); err != nil {
		return err
	}

	return fullSetup(ctx, r, result)
}

func JoinMembers(ctx context.Context, r *repo.Container,
	targetWorkspace accountsID.WorkspaceID,
	newUser *accountsUser.User,
	grantRole accountsRole.RoleType,
	invitedUserId accountsID.UserID,
) error {
	// Find workspace by ID
	w, err := r.Workspace.FindByID(ctx, targetWorkspace)
	if err != nil {
		return err
	}

	// Add new member to workspace
	newMembers := make(map[accountsID.UserID]accountsWorkspace.Member)
	for k, v := range w.Members().Users() {
		newMembers[k] = v
	}

	newMembers[newUser.ID()] = accountsWorkspace.Member{
		Role:      grantRole,
		InvitedBy: invitedUserId,
	}

	w2 := accountsWorkspace.New().
		ID(w.ID()).
		Name(w.Name()).
		Alias(w.Alias()).
		Personal(w.IsPersonal()).
		Members(newMembers).
		Metadata(*w.Metadata()).
		MustBuild()

	// Save updated workspace
	if err := r.Workspace.Save(ctx, w2); err != nil {
		return err
	}
	return nil
}

func baseSeederWithLang(ctx context.Context, r *repo.Container, f gateway.File, lang language.Tag, accountsClient *accountsGQLclient.Client, result *SeederResult) error {
	defer util.MockNow(now)()

	// Create user via API
	actualUID, actualWID, err := createUserAndWorkspaceViaAPI(ctx, accountsClient, result.WID, result.WAlias, result.UID, result.UName, result.UEmail, "Password123!", "")
	if err != nil {
		return err
	}
	// Update result with actual IDs from accounts service
	if actualUID != nil {
		result.UID = *actualUID
	}
	if actualWID != nil {
		result.WID = *actualWID
	}

	if _, err := seedAccountRepoUserWorkspace(ctx, r, result.UID, result.WID, result.UName, result.UEmail, result.WAlias); err != nil {
		return err
	}

	// TODO: Update user language via API after creation
	// For now, we create the user first and the language will use defaults

	return baseSetup(ctx, r, f, result)
}

func baseSetup(ctx context.Context, r *repo.Container, f gateway.File, result *SeederResult) error {

	url, err := addAsset("test.png", ctx, r, f, result)
	if err != nil {
		return err
	}

	p := project.New().ID(result.PID).
		Name(result.PName).
		Description(result.PDesc).
		ImageURL(url).
		Workspace(result.WID).
		Alias(result.PAlias).
		Visualizer(visualizer.VisualizerCesiumBeta).
		Visibility("private").
		CoreSupport(true).
		Starred(false).
		Deleted(false).
		MustBuild()
	if err := r.Project.Save(ctx, p); err != nil {
		return err
	}

	readme := "xxx readme"
	license := "yyy license"
	topics := []string{"gis", "history"}
	importResultLog := map[string]any{}

	st := project.ProjectImportStatusNone
	metadata, err := project.NewProjectMetadata().
		NewID().
		Workspace(result.WID).
		Project(result.PID).
		ImportStatus(&st).
		Readme(&readme).
		License(&license).
		Topics(&topics).
		ImportResultLog(&importResultLog).
		Build()
	if err != nil {
		return err
	}

	err = r.ProjectMetadata.Save(ctx, metadata)
	if err != nil {
		return err
	}
	return nil
}

func addAsset(path string, ctx context.Context, r *repo.Container, gf gateway.File, result *SeederResult) (*url.URL, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer func() {
		if cerr := f.Close(); cerr != nil && err == nil {
			err = cerr
		}
	}()
	stat, err := f.Stat()
	if err != nil {
		return nil, err
	}
	contentType := mime.TypeByExtension(filepath.Ext(path))
	if contentType == "" {
		contentType = "application/octet-stream"
	}

	u, size, err := gf.UploadAsset(ctx, &file.File{
		Content:     f,
		Path:        path,
		Size:        int64(stat.Size()),
		ContentType: contentType,
	})
	if err != nil {
		return nil, err
	}

	aid := id.NewAssetID()
	a := asset.New().
		ID(aid).
		Workspace(result.WID).
		Project(&result.PID).
		URL(u.String()).
		CreatedAt(aid.Timestamp()).
		Name(path).
		Size(size).
		ContentType(contentType).
		CoreSupport(true).
		MustBuild()
	return u, r.Asset.Save(ctx, a)
}

func fullSetup(ctx context.Context, r *repo.Container, result *SeederResult) error {
	schema := builtin.GetPropertySchemaByVisualizer(visualizer.VisualizerCesiumBeta)
	prop, err := property.New().NewID().Schema(schema.ID()).Scene(result.SID).Build()
	if err != nil {
		return err
	}
	ps := scene.NewPlugins([]*scene.Plugin{
		scene.NewPlugin(id.OfficialPluginID, nil),
	})
	s, err := scene.New().ID(result.SID).
		Project(result.PID).
		Workspace(result.WID).
		Property(prop.ID()).
		Plugins(ps).
		Build()
	if err != nil {
		return err
	}
	if err = r.Scene.Save(ctx, s); err != err {
		return err
	}
	if err = r.Property.Save(ctx, prop); err != err {
		return err
	}
	if err = addWidget(ctx, s, r, result); err != err {
		return err
	}
	if err = addStory(ctx, r, result); err != err {
		return err
	}
	if err = addLayerSimple(ctx, r, result); err != err {
		return err
	}
	if err = addLayerStyle(s.ID(), ctx, r); err != err {
		return err
	}
	return nil
}

func addWidget(ctx context.Context, s *scene.Scene, r *repo.Container, result *SeederResult) error {
	pluginID, err := id.PluginIDFrom("reearth")
	if err != nil {
		return err
	}
	eid := id.PluginExtensionID("dataAttribution")
	pr, err := r.Plugin.FindByID(ctx, pluginID)
	if err != nil {
		return err
	}
	extension := pr.Extension(eid)
	prop, err := property.New().NewID().Schema(extension.Schema()).Scene(result.SID).Build()
	if err != nil {
		return err
	}
	extended := false
	var location *plugin.WidgetLocation
	if widgetLayout := extension.WidgetLayout(); widgetLayout != nil {
		extended = widgetLayout.Extended()
		location = widgetLayout.DefaultLocation()
	}
	widget, err := scene.NewWidget(
		id.NewWidgetID(),
		pluginID,
		eid,
		prop.ID(),
		true,
		extended,
	)
	if err != nil {
		return err
	}
	s.Widgets().Add(widget)
	loc := scene.WidgetLocation{
		Zone:    scene.WidgetZoneType(location.Zone),
		Section: scene.WidgetSectionType(location.Section),
		Area:    scene.WidgetAreaType(location.Area),
	}
	s.Widgets().Alignment().System(scene.WidgetAlignSystemTypeDesktop).Area(loc).Add(widget.ID(), -1)
	s.Widgets().Alignment().System(scene.WidgetAlignSystemTypeMobile).Area(loc).Add(widget.ID(), -1)
	if err = r.Property.Save(ctx, prop); err != err {
		return err
	}
	if err = r.Scene.Save(ctx, s); err != err {
		return err
	}
	return nil
}

func addStory(ctx context.Context, r *repo.Container, result *SeederResult) error {
	schema := builtin.GetPropertySchema(builtin.PropertySchemaIDStory)
	prop, err := property.New().NewID().Schema(schema.ID()).Scene(result.SID).Build()
	if err != nil {
		return err
	}
	pages := []*storytelling.Page{}
	page, err := _createPage(ctx, r, result)
	if err != nil {
		return err
	}
	pages = append(pages, page)
	story, err := storytelling.NewStory().
		ID(result.StoryID).
		Title("test page").
		Pages(storytelling.NewPageList(pages)).
		Scene(result.SID).
		Property(prop.ID()).
		Build()
	if err != nil {
		return err
	}
	if err = r.Property.Save(ctx, prop); err != err {
		return err
	}
	if err := r.Storytelling.Save(ctx, *story); err != nil {
		return err
	}
	return err
}

func _createPage(ctx context.Context, r *repo.Container, result *SeederResult) (*storytelling.Page, error) {
	schema := builtin.GetPropertySchema(builtin.PropertySchemaIDStoryPage)
	prop, err := property.New().NewID().Schema(schema.ID()).Scene(result.SID).Build()
	if err != nil {
		return nil, err
	}
	if err = r.Property.Save(ctx, prop); err != err {
		return nil, err
	}

	blocks := []*storytelling.Block{}
	block, err := _createBlock(ctx, r, result)
	if err != nil {
		return nil, err
	}
	blocks = append(blocks, block)

	return storytelling.NewPage().
		ID(result.PageID).
		Title("Untitled").
		Blocks(blocks).
		Swipeable(false).
		Property(prop.ID()).
		Build()
}

func _createBlock(ctx context.Context, r *repo.Container, result *SeederResult) (*storytelling.Block, error) {
	plgID, err := id.PluginIDFrom("reearth")
	if err != nil {
		return nil, err
	}
	plg, err := r.Plugin.FindByID(ctx, plgID)
	if err != nil {
		return nil, err
	}
	eId := id.PluginExtensionID("textStoryBlock")
	extension := plg.Extension(eId)
	if extension.Type() != plugin.ExtensionTypeStoryBlock {
		return nil, err
	}
	prop, err := property.New().NewID().Schema(extension.Schema()).Scene(result.SID).Build()
	if err != nil {
		return nil, err
	}
	if err = r.Property.Save(ctx, prop); err != err {
		return nil, err
	}

	return storytelling.NewBlock().
		ID(result.BlockID).
		Plugin(plgID).
		Extension(eId).
		Property(prop.ID()).
		Build()
}

func addLayerStyle(SceneID id.SceneID, ctx context.Context, r *repo.Container) error {
	var s gqlmodel.JSON
	err := json.Unmarshal([]byte(`{
      "marker": {
        "show": true,
        "height": 100
      }
    }`), &s)
	if err != nil {
		return err
	}

	style, err := scene.NewStyle().
		NewID().
		Scene(SceneID).
		Name("Style.01").
		Value(gqlmodel.ToStyleValue(s)).Build()
	if err != nil {
		return err
	}
	if err := r.Style.Save(ctx, *style); err != nil {
		return err
	}
	return nil
}

func addLayerSimple(ctx context.Context, r *repo.Container, result *SeederResult) error {
	index := 0
	visible := true
	var config gqlmodel.JSON
	err := json.Unmarshal([]byte(`	{
		"data": {
		  "type": "geojson"
		},
		"layerStyleId": "",
		"properties": {
		  "name": "test simple layer"
		}
	  }`), &config)
	if err != nil {
		return err
	}

	layerSimple, err := nlslayer.NewNLSLayerSimple().
		ID(result.NLSLayerID).
		Scene(result.SID).
		Config(gqlmodel.ToNLSConfig(config)).
		LayerType(gqlmodel.ToNLSLayerType("simple")).
		Title("test simple layer").
		Index(&index).
		IsVisible(visible).
		Build()
	if err != nil {
		return err
	}
	featureCollection := nlslayer.NewFeatureCollection(
		"FeatureCollection",
		[]nlslayer.Feature{},
	)
	var schema map[string]any
	err = json.Unmarshal([]byte(`{
		  "aaa": "Text_1",
		  "bbb": "Int_2",
		  "ccc": "Boolean_3"
		}`), &schema)
	if err != nil {
		return err
	}
	sketchInfo := nlslayer.NewSketchInfo(
		&schema,
		featureCollection,
	)
	layerSimple.SetIsSketch(true)
	layerSimple.SetSketch(sketchInfo)
	if err = r.NLSLayer.Save(ctx, layerSimple); err != nil {
		return err
	}
	if err = addGeoJson(layerSimple.ID(), ctx, r); err != nil {
		return err
	}
	return nil
}

func addGeoJson(layerID nlslayer.ID, ctx context.Context, r *repo.Container) error {
	layerSimple, err := r.NLSLayer.FindByID(ctx, layerID)
	if err != nil {
		return err
	}
	var g map[string]any
	err = json.Unmarshal([]byte(`{
		"coordinates": [ 139.75315985724345, 35.68234704867425 ],
		"type": "Point"
	}`), &g)
	if err != nil {
		return err
	}

	geometry, err := nlslayer.NewGeometryFromMap(g)
	if err != nil {
		fmt.Print(err)
		return err
	}

	feature, err := nlslayer.NewFeature(
		id.NewFeatureID(),
		"Feature",
		geometry,
	)
	if err != nil {
		return err
	}
	var p map[string]any

	err = json.Unmarshal([]byte(fmt.Sprintf(`{
		"extrudedHeight": 0,
		"id": "%s",
		"positions": [
		[
			-3958794.1421583104,
			3350991.8464303534,
			3699620.1697127568
		]
		],
		"type": "marker"
	}`, generateUUID())), &p)
	if err != nil {
		return err
	}
	feature.UpdateProperties(&p)
	featureCollection := nlslayer.NewFeatureCollection(
		"FeatureCollection",
		[]nlslayer.Feature{*feature},
	)
	sketchInfo := nlslayer.NewSketchInfo(
		layerSimple.Sketch().CustomPropertySchema(),
		featureCollection,
	)
	layerSimple.SetIsSketch(true)
	layerSimple.SetSketch(sketchInfo)
	if err = r.NLSLayer.Save(ctx, layerSimple); err != nil {
		return err
	}
	return nil
}

func generateUUID() string {
	b := make([]byte, 16)
	_, err := rand.Read(b)
	if err != nil {
		panic(err)
	}
	b[6] = (b[6] & 0x0F) | 0x40
	b[8] = (b[8] & 0x3F) | 0x80
	return fmt.Sprintf("%s-%s-%s-%s-%s",
		hex.EncodeToString(b[0:4]),
		hex.EncodeToString(b[4:6]),
		hex.EncodeToString(b[6:8]),
		hex.EncodeToString(b[8:10]),
		hex.EncodeToString(b[10:16]),
	)
}
