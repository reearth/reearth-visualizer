//go:build e2e

package e2e

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"sync"
	"time"

	accountsGQLclient "github.com/reearth/reearth-accounts/server/pkg/gqlclient"
	accountsWorkspaceGQL "github.com/reearth/reearth-accounts/server/pkg/gqlclient/workspace"
	accountsID "github.com/reearth/reearth-accounts/server/pkg/id"
	"github.com/reearth/reearth/server/internal/adapter"
)

var (
	demoUserOnce sync.Once
)

// Note: ensureRoles has been removed. The reearth-accounts service now auto-creates
// required roles when REEARTH_MOCK_AUTH=true is enabled.

func ensureDemoUser(ctx context.Context, client *accountsGQLclient.Client) error {
	var err error
	demoUserOnce.Do(func() {
		names := []string{"Demo user", "Demo user 2", "Demo user 3"}
		for _, name := range names {
			uid := accountsID.NewUserID().String()
			wid := accountsID.NewWorkspaceID().String()
			email := fmt.Sprintf("demo+%s+%d@e2e.com", strings.ReplaceAll(name, " ", "-"), time.Now().UnixNano())
			// Pass mockAuth=true for E2E tests to auto-create roles
			_, err = client.UserRepo.Signup(ctx, uid, name, email, "Password123!", "", wid, true)
			if err != nil {
				if strings.Contains(err.Error(), "already exists") {
					err = nil
					continue
				}
				return
			}
		}
	})
	return err
}

// createUserAndWorkspaceViaAPI creates a user and workspace using the accounts API client
// Returns the actual user ID and workspace ID created by the accounts service
// Note: The uid and wid parameters are hints, but the actual IDs are generated by the accounts service
func createUserAndWorkspaceViaAPI(
	ctx context.Context,
	client *accountsGQLclient.Client,
	wid accountsID.WorkspaceID,
	wAlias string,
	uid accountsID.UserID,
	name string,
	email string,
	password string,
	secret string) (*accountsID.UserID, *accountsID.WorkspaceID, error) {

	if client == nil {
		return nil, nil, fmt.Errorf("accountsAPIClient is nil")
	}

	// Note: Role auto-creation is now handled by reearth-accounts when REEARTH_MOCK_AUTH=true

	if err := ensureDemoUser(ctx, client); err != nil {
		return nil, nil, fmt.Errorf("failed to ensure demo user: %w", err)
	}

	// Create user via API with mock auth enabled for E2E tests
	// Pass the IDs we generated - the API should use them or return the actual IDs it created
	signupResult, err := client.UserRepo.Signup(ctx, uid.String(), name, email, password, secret, wid.String(), true)
	if err != nil {
		// Check if user already exists
		errStr := err.Error()
		if strings.Contains(errStr, "user already exists") || strings.Contains(errStr, "already exists") {
			// User already exists from a previous test run
			// We cannot retrieve the existing user's ID easily, so we'll have to skip this
			// This is a limitation of the current test infrastructure
			return nil, nil, fmt.Errorf("user with email %s already exists in accounts service - please clean the accounts database: %w", email, err)
		}
		return nil, nil, fmt.Errorf("failed to create user via API: %w", err)
	}

	// Parse the actual user ID returned by the signup
	actualUID, err := accountsID.UserIDFrom(signupResult.ID().String())
	if err != nil {
		return nil, nil, fmt.Errorf("failed to parse user ID from signup result: %w", err)
	}

	// Create a non-personal workspace for tests (personal workspaces cannot be modified).
	ctxWithUser := adapter.AttachUserID(ctx, actualUID.String())
	if host := accountsHostFromContext(ctxWithUser); host != "" {
		createdID, createdAlias, personal, err := createWorkspaceViaHTTP(ctxWithUser, host, name, wAlias, actualUID.String())
		if err != nil {
			if strings.Contains(err.Error(), "already exists") || strings.Contains(err.Error(), "already") {
				foundID, findErr := findNonPersonalWorkspaceByAlias(ctxWithUser, client, actualUID.String(), wAlias)
				if findErr != nil {
					return nil, nil, fmt.Errorf("failed to find existing workspaces for user %s: %w", actualUID.String(), findErr)
				}
				if foundID != nil {
					return &actualUID, foundID, nil
				}
			} else {
				return nil, nil, fmt.Errorf("failed to create workspace via HTTP: %w", err)
			}
		} else if createdID != "" && !personal {
			actualWID, parseErr := accountsID.WorkspaceIDFrom(createdID)
			if parseErr != nil {
				return nil, nil, fmt.Errorf("failed to parse workspace ID from HTTP response: %w", parseErr)
			}
			if createdAlias == wAlias {
				return &actualUID, &actualWID, nil
			}
			foundID, findErr := findNonPersonalWorkspaceByAlias(ctxWithUser, client, actualUID.String(), wAlias)
			if findErr == nil && foundID != nil {
				return &actualUID, foundID, nil
			}
			return &actualUID, &actualWID, nil
		}
	}

	ws, err := client.WorkspaceRepo.CreateWorkspace(ctxWithUser, accountsWorkspaceGQL.CreateWorkspaceInput{
		Alias: wAlias,
		Name:  name,
	})
	if err != nil {
		if strings.Contains(err.Error(), "already exists") || strings.Contains(err.Error(), "already") {
			foundID, findErr := findNonPersonalWorkspaceByAlias(ctxWithUser, client, actualUID.String(), wAlias)
			if findErr != nil {
				return nil, nil, fmt.Errorf("failed to find existing workspaces for user %s: %w", actualUID.String(), findErr)
			}
			if foundID != nil {
				return &actualUID, foundID, nil
			}
		}
		return nil, nil, fmt.Errorf("failed to create workspace via API: %w", err)
	}

	if ws.IsPersonal() {
		foundID, findErr := findNonPersonalWorkspaceByAlias(ctxWithUser, client, actualUID.String(), wAlias)
		if findErr != nil {
			return nil, nil, fmt.Errorf("failed to find non-personal workspace for user %s: %w", actualUID.String(), findErr)
		}
		if foundID != nil {
			return &actualUID, foundID, nil
		}
		return nil, nil, fmt.Errorf("created workspace is personal and unusable for tests")
	}

	actualWID := ws.ID()

	// Note: The Signup API creates both the user and their personal workspace
	// The actual IDs returned might differ from what we requested

	return &actualUID, &actualWID, nil
}

// addUserToWorkspaceViaAPI adds a user to an existing workspace
func addUserToWorkspaceViaAPI(
	ctx context.Context,
	client *accountsGQLclient.Client,
	workspaceID accountsID.WorkspaceID,
	userID accountsID.UserID,
	role string,
	actorUserID accountsID.UserID,
) error {

	if client == nil {
		return fmt.Errorf("accountsAPIClient is nil")
	}

	if err := ensureDemoUser(ctx, client); err != nil {
		return fmt.Errorf("failed to ensure demo user: %w", err)
	}

	if actorUserID.String() != "" {
		ctx = adapter.AttachUserID(ctx, actorUserID.String())
	}

	// Add user to workspace via direct GraphQL to avoid gqlclient type inference issues.
	host := accountsHostFromContext(ctx)
	if host == "" {
		return fmt.Errorf("accounts host is missing from context")
	}

	err := addUsersToWorkspaceViaHTTP(ctx, host, workspaceID.String(), userID.String(), role, actorUserID.String())
	if err != nil {
		// Check if user is already a member or workspace doesn't exist - if so, skip addition
		errStr := err.Error()
		if strings.Contains(errStr, "already") ||
			strings.Contains(errStr, "member") ||
			strings.Contains(errStr, "422") ||
			strings.Contains(errStr, "Unprocessable Entity") {
			// User already a member or workspace issue, this is OK for tests
			return nil
		}
		return fmt.Errorf("failed to add user to workspace via API: %w", err)
	}

	return nil
}

type addUsersToWorkspaceResponse struct {
	Errors []struct {
		Message string `json:"message"`
	} `json:"errors"`
}

type createWorkspaceResponse struct {
	Data struct {
		CreateWorkspace struct {
			Workspace struct {
				ID       string `json:"id"`
				Alias    string `json:"alias"`
				Personal bool   `json:"personal"`
			} `json:"workspace"`
		} `json:"createWorkspace"`
	} `json:"data"`
	Errors []struct {
		Message string `json:"message"`
	} `json:"errors"`
}

func findNonPersonalWorkspaceByAlias(
	ctx context.Context,
	client *accountsGQLclient.Client,
	userID string,
	alias string,
) (*accountsID.WorkspaceID, error) {
	existing, err := client.WorkspaceRepo.FindByUser(ctx, userID)
	if err != nil {
		return nil, err
	}
	for _, w := range existing {
		if w.Alias() == alias && !w.IsPersonal() {
			id := w.ID()
			return &id, nil
		}
	}
	return nil, nil
}

func createWorkspaceViaHTTP(ctx context.Context, host, name, alias, actorUserID string) (string, string, bool, error) {
	query := `mutation CreateWorkspace($input: CreateWorkspaceInput!) {
  createWorkspace(input: $input) {
    workspace {
      id
      alias
      personal
    }
  }
}`

	payload := map[string]interface{}{
		"query": query,
		"variables": map[string]interface{}{
			"input": map[string]interface{}{
				"name":  name,
				"alias": alias,
			},
		},
	}

	body, err := json.Marshal(payload)
	if err != nil {
		return "", "", false, fmt.Errorf("failed to marshal GraphQL payload: %w", err)
	}

	endpoint := strings.TrimRight(host, "/") + "/api/graphql"
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, endpoint, bytes.NewReader(body))
	if err != nil {
		return "", "", false, fmt.Errorf("failed to build GraphQL request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-Internal-Service", "visualizer-api")
	if actorUserID != "" {
		req.Header.Set("X-Reearth-Debug-User", actorUserID)
	}

	httpClient := &http.Client{Timeout: 30 * time.Second}
	resp, err := httpClient.Do(req)
	if err != nil {
		return "", "", false, fmt.Errorf("failed to call accounts GraphQL: %w", err)
	}
	defer resp.Body.Close()

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", "", false, fmt.Errorf("failed to read accounts GraphQL response: %w", err)
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return "", "", false, fmt.Errorf("accounts GraphQL status %s: %s", resp.Status, strings.TrimSpace(string(respBody)))
	}

	var gqlResp createWorkspaceResponse
	if err := json.Unmarshal(respBody, &gqlResp); err != nil {
		return "", "", false, fmt.Errorf("failed to parse accounts GraphQL response: %w", err)
	}
	if len(gqlResp.Errors) > 0 {
		messages := make([]string, 0, len(gqlResp.Errors))
		for _, ge := range gqlResp.Errors {
			if ge.Message != "" {
				messages = append(messages, ge.Message)
			}
		}
		if len(messages) > 0 {
			return "", "", false, fmt.Errorf("accounts GraphQL errors: %s", strings.Join(messages, "; "))
		}
		return "", "", false, fmt.Errorf("accounts GraphQL errors returned")
	}

	ws := gqlResp.Data.CreateWorkspace.Workspace
	return ws.ID, ws.Alias, ws.Personal, nil
}

func addUsersToWorkspaceViaHTTP(ctx context.Context, host, workspaceID, userID, role, actorUserID string) error {
	query := `mutation AddUsersToWorkspace($input: AddUsersToWorkspaceInput!) {
  addUsersToWorkspace(input: $input) {
    workspace {
      id
      name
      alias
      personal
    }
  }
}`

	payload := map[string]interface{}{
		"query": query,
		"variables": map[string]interface{}{
			"input": map[string]interface{}{
				"workspaceId": workspaceID,
				"users": []map[string]interface{}{
					{
						"userId": userID,
						"role":   role,
					},
				},
			},
		},
	}

	body, err := json.Marshal(payload)
	if err != nil {
		return fmt.Errorf("failed to marshal GraphQL payload: %w", err)
	}

	endpoint := strings.TrimRight(host, "/") + "/api/graphql"
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, endpoint, bytes.NewReader(body))
	if err != nil {
		return fmt.Errorf("failed to build GraphQL request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-Internal-Service", "visualizer-api")
	if actorUserID != "" {
		req.Header.Set("X-Reearth-Debug-User", actorUserID)
	}

	client := &http.Client{Timeout: 30 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("failed to call accounts GraphQL: %w", err)
	}
	defer resp.Body.Close()

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read accounts GraphQL response: %w", err)
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("accounts GraphQL status %s: %s", resp.Status, strings.TrimSpace(string(respBody)))
	}

	var gqlResp addUsersToWorkspaceResponse
	if err := json.Unmarshal(respBody, &gqlResp); err != nil {
		return fmt.Errorf("failed to parse accounts GraphQL response: %w", err)
	}
	if len(gqlResp.Errors) > 0 {
		messages := make([]string, 0, len(gqlResp.Errors))
		for _, ge := range gqlResp.Errors {
			if ge.Message != "" {
				messages = append(messages, ge.Message)
			}
		}
		if len(messages) > 0 {
			return fmt.Errorf("accounts GraphQL errors: %s", strings.Join(messages, "; "))
		}
		return fmt.Errorf("accounts GraphQL errors returned")
	}

	return nil
}
