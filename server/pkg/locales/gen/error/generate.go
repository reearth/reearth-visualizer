package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"unicode"

	"golang.org/x/text/language"
	"golang.org/x/text/language/display"
)

// MessageDefinition holds information for a single translation message.
type MessageDefinition struct {
	ID    string
	Other string
}

// CollectKeysAndMessages collects message information from the flat JSON object.
func CollectKeysAndMessages(data map[string]interface{}) []MessageDefinition {
	var messages []MessageDefinition
	for k, v := range data {
		if message, ok := v.(string); ok {
			messages = append(messages, MessageDefinition{
				ID:    k,
				Other: message,
			})
		}
	}
	return messages
}

// generateKeyConstants generates Go code for key constants.
func generateKeyConstants(messages []MessageDefinition) string {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by go generate; DO NOT EDIT.\n")
	buf.WriteString("package locales\n\n")
	buf.WriteString("const (\n")
	for _, msg := range messages {
		constName := "ErrKey" + toCamelCase(msg.ID)
		buf.WriteString(fmt.Sprintf("\t%s = \"%s\"\n", constName, msg.ID))
	}
	buf.WriteString(")\n")
	return buf.String()
}

// generateCode generates Go code for the provided language and messages.
func generateCode(lang string, messages []MessageDefinition) string {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by go generate; DO NOT EDIT.\n")
	buf.WriteString("package locales\n\nimport (\n\t\"github.com/reearth/reearthx/i18n\"\n\t\"golang.org/x/text/language\"\n)\n\n")
	buf.WriteString(fmt.Sprintf("func add%sErrorMessages(bundle *i18n.Bundle) {\n", capitalize(lang)))

	for _, msg := range messages {
		buf.WriteString(fmt.Sprintf("\tbundle.MustAddMessages(language.%s, &i18n.Message{\n", display.English.Tags().Name(language.Make(lang))))
		buf.WriteString(fmt.Sprintf("\t\tID:    \"%s\",\n", msg.ID))
		buf.WriteString(fmt.Sprintf("\t\tOther: \"%s\",\n", msg.Other))
		buf.WriteString("\t})\n")
	}

	buf.WriteString("}\n")
	return buf.String()
}

// toCamelCase converts a dot-delimited key to CamelCase.
func toCamelCase(input string) string {
	parts := strings.Split(input, ".")
	for i, part := range parts {
		parts[i] = convertToCamel(part)
	}
	return strings.Join(parts, "")
}

// convertToCamel converts a single part to CamelCase.
func convertToCamel(part string) string {
	subParts := strings.Split(part, "_")
	for i, sub := range subParts {
		subParts[i] = capitalize(sub)
	}
	return strings.Join(subParts, "")
}

// capitalize makes the first letter of a string uppercase.
func capitalize(s string) string {
	if len(s) == 0 {
		return s
	}
	return string(unicode.ToUpper(rune(s[0]))) + s[1:]
}

func main() {
	langs := []string{"en", "ja"}
	keyOutputFile := "errorkey_gen.go"
	for _, lang := range langs {
		jsonFile := fmt.Sprintf("error.%s.json", lang)
		outputFile := fmt.Sprintf("error%s_gen.go", lang)

		file, err := os.Open(jsonFile)
		if err != nil {
			panic(err)
		}

		defer func() {
			if err := file.Close(); err != nil {
				panic(err)
			}
		}()

		var data map[string]interface{}
		if err := json.NewDecoder(file).Decode(&data); err != nil {
			panic(err)
		}

		// Collect messages from JSON
		messages := CollectKeysAndMessages(data)

		// Generate key constants
		if lang == "en" { // Generate keys only once
			keyCode := generateKeyConstants(messages)
			if err := os.WriteFile(keyOutputFile, []byte(keyCode), 0644); err != nil {
				panic(err)
			}
		}

		// Generate Go file for each language
		langCode := generateCode(lang, messages)
		if err := os.WriteFile(outputFile, []byte(langCode), 0644); err != nil {
			panic(err)
		}
	}
}
