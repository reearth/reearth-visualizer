//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"golang.org/x/text/language"
	"golang.org/x/text/language/display"
)

func main() {
	inputDir := "../locales/entitymsg"
	outputFile := "./entitymsg/entitymsg_generated.go"

	files, err := collectJSONFiles(inputDir)
	if err != nil {
		panic(fmt.Errorf("failed to collect JSON files: %w", err))
	}

	translations, err := loadEntityMessages(files)
	if err != nil {
		panic(fmt.Errorf("failed to load entity messages: %w", err))
	}

	code := generateEntityCode(translations)

	if err := os.WriteFile(outputFile, []byte(code), 0644); err != nil {
		panic(fmt.Errorf("failed to write output file: %w", err))
	}

	fmt.Println("Code generated:", outputFile)
}

// collectJSONFiles collects all JSON files from the given directory.
func collectJSONFiles(dir string) ([]string, error) {
	var files []string
	err := filepath.WalkDir(dir, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() && filepath.Ext(d.Name()) == ".json" {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}

// loadEntityMessages loads and flattens nested entity message JSON files into a flat map.
func loadEntityMessages(files []string) (map[string]map[language.Tag]string, error) {
	messages := make(map[string]map[language.Tag]string)
	for _, file := range files {
		lang := language.Make(extractLanguageCode(file))

		data, err := os.ReadFile(file)
		if err != nil {
			return nil, fmt.Errorf("failed to read file %s: %w", file, err)
		}

		var nested map[string]interface{}
		if err := json.Unmarshal(data, &nested); err != nil {
			return nil, fmt.Errorf("failed to parse file %s: %w", file, err)
		}

		flatMessages := flattenJSON(nested, "")

		for key, value := range flatMessages {
			if _, exists := messages[key]; !exists {
				messages[key] = make(map[language.Tag]string)
			}
			messages[key][lang] = value
		}
	}
	return messages, nil
}

// extractLanguageCode extracts the language code from a file name (e.g., en.json -> en).
func extractLanguageCode(fileName string) string {
	base := filepath.Base(fileName)
	return strings.TrimSuffix(base, filepath.Ext(base))
}

// flattenJSON flattens a nested JSON object into a flat map with dot-delimited keys.
func flattenJSON(data map[string]interface{}, parentKey string) map[string]string {
	flat := make(map[string]string)

	for key, value := range data {
		fullKey := key
		if parentKey != "" {
			fullKey = parentKey + "." + key
		}

		switch v := value.(type) {
		case string:
			flat[fullKey] = v
		case map[string]interface{}:
			nestedFlat := flattenJSON(v, fullKey)
			for k, val := range nestedFlat {
				flat[k] = val
			}
		}
	}

	return flat
}

// generateEntityCode generates Go code for the entity messages and their constants.
func generateEntityCode(messages map[string]map[language.Tag]string) string {
	var buf bytes.Buffer

	funcMap := template.FuncMap{
		"toCamelCase": toCamelCase,
		"tagToString": func(tag language.Tag) string {
			return fmt.Sprintf("language.%s", display.English.Languages().Name(language.Make(tag.String())))
		},
	}

	tmpl := template.Must(template.New("entitymsg").Funcs(funcMap).Parse(`// Code generated by go generate; DO NOT EDIT.
package entitymsg

import (
	"golang.org/x/text/language"
	"github.com/reearth/reearth/server/pkg/i18n/message"
)

const (
{{- range $key := .Keys }}
	EntityKey{{ toCamelCase $key }} message.EntityKey = "{{$key}}"
{{- end }}
)

var EntityMessages = map[message.EntityKey]map[language.Tag]string{
{{- range $key, $langs := .Messages }}
	EntityKey{{ toCamelCase $key }}: {
		{{- range $lang, $msg := $langs }}
		{{ tagToString $lang }}: "{{$msg}}",
		{{- end }}
	},
{{- end }}
}

func GetLocalizedEntityMessage(key message.EntityKey, locale language.Tag) string {
	if msg, ok := EntityMessages[key][locale]; ok {
		return msg
	}
	return ""
}
`))

	keys := extractSortedKeys(messages)
	data := map[string]interface{}{
		"Messages": messages,
		"Keys":     keys,
	}
	if err := tmpl.Execute(&buf, data); err != nil {
		panic(fmt.Errorf("failed to execute template: %w", err))
	}

	return buf.String()
}

// extractSortedKeys extracts and sorts the keys from the messages map.
func extractSortedKeys(messages map[string]map[language.Tag]string) []string {
	keys := make([]string, 0, len(messages))
	for key := range messages {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	return keys
}

// toCamelCase converts dot-separated keys (and handles snake_case) to CamelCase.
func toCamelCase(input string) string {
	parts := strings.Split(input, ".")
	for i, part := range parts {
		subParts := strings.Split(part, "_")
		for j, subPart := range subParts {
			subParts[j] = strings.Title(subPart)
		}
		parts[i] = strings.Join(subParts, "")
	}
	return strings.Join(parts, "")
}
